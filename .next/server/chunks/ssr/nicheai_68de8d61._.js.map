{"version":3,"sources":["../../../../../nicheai/lib/wagmi.ts","../../../../../nicheai/node_modules/%40wagmi/core/node_modules/zustand/esm/middleware.mjs","../../../../../nicheai/node_modules/%40wagmi/core/node_modules/zustand/esm/vanilla.mjs","../../../../../nicheai/lib/providers.tsx","../../../../../nicheai/node_modules/%40tanstack/react-query/node_modules/%40tanstack/query-core/build/modern/queryClient.js","../../../../../nicheai/node_modules/%40wagmi/core/src/utils/uid.ts","../../../../../nicheai/node_modules/%40wagmi/core/src/utils/extractRpcUrls.ts","../../../../../nicheai/node_modules/%40wagmi/core/src/utils/deserialize.ts","../../../../../nicheai/node_modules/%40wagmi/connectors/src/walletConnect.ts","../../../../../nicheai/node_modules/%40wagmi/core/src/createConfig.ts","../../../../../nicheai/node_modules/%40wagmi/core/src/connectors/injected.ts","../../../../../nicheai/node_modules/%40wagmi/connectors/src/coinbaseWallet.ts","../../../../../nicheai/node_modules/%40wagmi/core/src/createStorage.ts","../../../../../nicheai/node_modules/%40wagmi/core/src/createEmitter.ts","../../../../../nicheai/node_modules/%40wagmi/core/src/connectors/createConnector.ts","../../../../../nicheai/node_modules/viem/chains/definitions/mainnet.ts","../../../../../nicheai/node_modules/viem/chains/definitions/baseSepolia.ts","../../../../../nicheai/node_modules/%40tanstack/react-query/node_modules/%40tanstack/query-core/src/queryCache.ts","../../../../../nicheai/node_modules/%40tanstack/react-query/node_modules/%40tanstack/query-core/build/modern/queryCache.js","../../../../../nicheai/node_modules/%40tanstack/react-query/node_modules/%40tanstack/query-core/build/modern/mutationCache.js","../../../../../nicheai/node_modules/%40tanstack/react-query/node_modules/%40tanstack/query-core/src/mutationCache.ts","../../../../../nicheai/node_modules/%40tanstack/react-query/node_modules/%40tanstack/query-core/build/modern/infiniteQueryBehavior.js","../../../../../nicheai/node_modules/%40wagmi/core/src/utils/serialize.ts","../../../../../nicheai/node_modules/%40tanstack/react-query/node_modules/%40tanstack/query-core/src/infiniteQueryBehavior.ts","../../../../../nicheai/node_modules/%40tanstack/react-query/node_modules/%40tanstack/query-core/src/queryClient.ts","../../../../../nicheai/components/FloatingChatWidget.tsx","../../../../../nicheai/components/ChatbotAvatar.tsx","../../../../../nicheai/components/AtlasChatWidget.tsx"],"sourcesContent":["import { http, createConfig } from \"wagmi\";\nimport { base, baseSepolia, mainnet } from \"wagmi/chains\";\nimport { coinbaseWallet, injected, walletConnect } from \"wagmi/connectors\";\n\n// Define Niche Network (local Optimism testnet)\nconst nicheNetwork = {\n  id: 901,\n  name: \"Niche Network\",\n  network: \"niche-network\",\n  nativeCurrency: {\n    decimals: 18,\n    name: \"Ether\",\n    symbol: \"ETH\",\n  },\n  rpcUrls: {\n    default: {\n      http: [\"http://localhost:8545\"],\n    },\n    public: {\n      http: [\"http://localhost:8545\"],\n    },\n  },\n  blockExplorers: {\n    default: { name: \"Niche Explorer\", url: \"\" },\n  },\n  testnet: true,\n};\n\nexport const config = createConfig({\n  chains: [base, baseSepolia, mainnet],\n  connectors: [\n    coinbaseWallet({\n      appName: \"NicheAI\",\n      preference: \"smartWalletOnly\",\n    }),\n    injected({ shimDisconnect: true }),\n    walletConnect({\n      projectId: process.env.NEXT_PUBLIC_WALLETCONNECT_PROJECT_ID || \"c5ca7a3d3e1c52b7abfbc0e7c1e8f1d4\",\n      showQrModal: true,\n    }),\n  ],\n  ssr: true,\n  transports: {\n    [base.id]: http(),\n    [baseSepolia.id]: http(),\n    [mainnet.id]: http(),\n  },\n});\n","const reduxImpl = (reducer, initial) => (set, _get, api) => {\n  api.dispatch = (action) => {\n    set((state) => reducer(state, action), false, action);\n    return action;\n  };\n  api.dispatchFromDevtools = true;\n  return { dispatch: (...a) => api.dispatch(...a), ...initial };\n};\nconst redux = reduxImpl;\n\nconst trackedConnections = /* @__PURE__ */ new Map();\nconst getTrackedConnectionState = (name) => {\n  const api = trackedConnections.get(name);\n  if (!api) return {};\n  return Object.fromEntries(\n    Object.entries(api.stores).map(([key, api2]) => [key, api2.getState()])\n  );\n};\nconst extractConnectionInformation = (store, extensionConnector, options) => {\n  if (store === void 0) {\n    return {\n      type: \"untracked\",\n      connection: extensionConnector.connect(options)\n    };\n  }\n  const existingConnection = trackedConnections.get(options.name);\n  if (existingConnection) {\n    return { type: \"tracked\", store, ...existingConnection };\n  }\n  const newConnection = {\n    connection: extensionConnector.connect(options),\n    stores: {}\n  };\n  trackedConnections.set(options.name, newConnection);\n  return { type: \"tracked\", store, ...newConnection };\n};\nconst devtoolsImpl = (fn, devtoolsOptions = {}) => (set, get, api) => {\n  const { enabled, anonymousActionType, store, ...options } = devtoolsOptions;\n  let extensionConnector;\n  try {\n    extensionConnector = (enabled != null ? enabled : (import.meta.env ? import.meta.env.MODE : void 0) !== \"production\") && window.__REDUX_DEVTOOLS_EXTENSION__;\n  } catch (e) {\n  }\n  if (!extensionConnector) {\n    return fn(set, get, api);\n  }\n  const { connection, ...connectionInformation } = extractConnectionInformation(store, extensionConnector, options);\n  let isRecording = true;\n  api.setState = (state, replace, nameOrAction) => {\n    const r = set(state, replace);\n    if (!isRecording) return r;\n    const action = nameOrAction === void 0 ? { type: anonymousActionType || \"anonymous\" } : typeof nameOrAction === \"string\" ? { type: nameOrAction } : nameOrAction;\n    if (store === void 0) {\n      connection == null ? void 0 : connection.send(action, get());\n      return r;\n    }\n    connection == null ? void 0 : connection.send(\n      {\n        ...action,\n        type: `${store}/${action.type}`\n      },\n      {\n        ...getTrackedConnectionState(options.name),\n        [store]: api.getState()\n      }\n    );\n    return r;\n  };\n  const setStateFromDevtools = (...a) => {\n    const originalIsRecording = isRecording;\n    isRecording = false;\n    set(...a);\n    isRecording = originalIsRecording;\n  };\n  const initialState = fn(api.setState, get, api);\n  if (connectionInformation.type === \"untracked\") {\n    connection == null ? void 0 : connection.init(initialState);\n  } else {\n    connectionInformation.stores[connectionInformation.store] = api;\n    connection == null ? void 0 : connection.init(\n      Object.fromEntries(\n        Object.entries(connectionInformation.stores).map(([key, store2]) => [\n          key,\n          key === connectionInformation.store ? initialState : store2.getState()\n        ])\n      )\n    );\n  }\n  if (api.dispatchFromDevtools && typeof api.dispatch === \"function\") {\n    let didWarnAboutReservedActionType = false;\n    const originalDispatch = api.dispatch;\n    api.dispatch = (...a) => {\n      if ((import.meta.env ? import.meta.env.MODE : void 0) !== \"production\" && a[0].type === \"__setState\" && !didWarnAboutReservedActionType) {\n        console.warn(\n          '[zustand devtools middleware] \"__setState\" action type is reserved to set state from the devtools. Avoid using it.'\n        );\n        didWarnAboutReservedActionType = true;\n      }\n      originalDispatch(...a);\n    };\n  }\n  connection.subscribe((message) => {\n    var _a;\n    switch (message.type) {\n      case \"ACTION\":\n        if (typeof message.payload !== \"string\") {\n          console.error(\n            \"[zustand devtools middleware] Unsupported action format\"\n          );\n          return;\n        }\n        return parseJsonThen(\n          message.payload,\n          (action) => {\n            if (action.type === \"__setState\") {\n              if (store === void 0) {\n                setStateFromDevtools(action.state);\n                return;\n              }\n              if (Object.keys(action.state).length !== 1) {\n                console.error(\n                  `\n                    [zustand devtools middleware] Unsupported __setState action format.\n                    When using 'store' option in devtools(), the 'state' should have only one key, which is a value of 'store' that was passed in devtools(),\n                    and value of this only key should be a state object. Example: { \"type\": \"__setState\", \"state\": { \"abc123Store\": { \"foo\": \"bar\" } } }\n                    `\n                );\n              }\n              const stateFromDevtools = action.state[store];\n              if (stateFromDevtools === void 0 || stateFromDevtools === null) {\n                return;\n              }\n              if (JSON.stringify(api.getState()) !== JSON.stringify(stateFromDevtools)) {\n                setStateFromDevtools(stateFromDevtools);\n              }\n              return;\n            }\n            if (!api.dispatchFromDevtools) return;\n            if (typeof api.dispatch !== \"function\") return;\n            api.dispatch(action);\n          }\n        );\n      case \"DISPATCH\":\n        switch (message.payload.type) {\n          case \"RESET\":\n            setStateFromDevtools(initialState);\n            if (store === void 0) {\n              return connection == null ? void 0 : connection.init(api.getState());\n            }\n            return connection == null ? void 0 : connection.init(getTrackedConnectionState(options.name));\n          case \"COMMIT\":\n            if (store === void 0) {\n              connection == null ? void 0 : connection.init(api.getState());\n              return;\n            }\n            return connection == null ? void 0 : connection.init(getTrackedConnectionState(options.name));\n          case \"ROLLBACK\":\n            return parseJsonThen(message.state, (state) => {\n              if (store === void 0) {\n                setStateFromDevtools(state);\n                connection == null ? void 0 : connection.init(api.getState());\n                return;\n              }\n              setStateFromDevtools(state[store]);\n              connection == null ? void 0 : connection.init(getTrackedConnectionState(options.name));\n            });\n          case \"JUMP_TO_STATE\":\n          case \"JUMP_TO_ACTION\":\n            return parseJsonThen(message.state, (state) => {\n              if (store === void 0) {\n                setStateFromDevtools(state);\n                return;\n              }\n              if (JSON.stringify(api.getState()) !== JSON.stringify(state[store])) {\n                setStateFromDevtools(state[store]);\n              }\n            });\n          case \"IMPORT_STATE\": {\n            const { nextLiftedState } = message.payload;\n            const lastComputedState = (_a = nextLiftedState.computedStates.slice(-1)[0]) == null ? void 0 : _a.state;\n            if (!lastComputedState) return;\n            if (store === void 0) {\n              setStateFromDevtools(lastComputedState);\n            } else {\n              setStateFromDevtools(lastComputedState[store]);\n            }\n            connection == null ? void 0 : connection.send(\n              null,\n              // FIXME no-any\n              nextLiftedState\n            );\n            return;\n          }\n          case \"PAUSE_RECORDING\":\n            return isRecording = !isRecording;\n        }\n        return;\n    }\n  });\n  return initialState;\n};\nconst devtools = devtoolsImpl;\nconst parseJsonThen = (stringified, f) => {\n  let parsed;\n  try {\n    parsed = JSON.parse(stringified);\n  } catch (e) {\n    console.error(\n      \"[zustand devtools middleware] Could not parse the received json\",\n      e\n    );\n  }\n  if (parsed !== void 0) f(parsed);\n};\n\nconst subscribeWithSelectorImpl = (fn) => (set, get, api) => {\n  const origSubscribe = api.subscribe;\n  api.subscribe = (selector, optListener, options) => {\n    let listener = selector;\n    if (optListener) {\n      const equalityFn = (options == null ? void 0 : options.equalityFn) || Object.is;\n      let currentSlice = selector(api.getState());\n      listener = (state) => {\n        const nextSlice = selector(state);\n        if (!equalityFn(currentSlice, nextSlice)) {\n          const previousSlice = currentSlice;\n          optListener(currentSlice = nextSlice, previousSlice);\n        }\n      };\n      if (options == null ? void 0 : options.fireImmediately) {\n        optListener(currentSlice, currentSlice);\n      }\n    }\n    return origSubscribe(listener);\n  };\n  const initialState = fn(set, get, api);\n  return initialState;\n};\nconst subscribeWithSelector = subscribeWithSelectorImpl;\n\nconst combine = (initialState, create) => (...a) => Object.assign({}, initialState, create(...a));\n\nfunction createJSONStorage(getStorage, options) {\n  let storage;\n  try {\n    storage = getStorage();\n  } catch (e) {\n    return;\n  }\n  const persistStorage = {\n    getItem: (name) => {\n      var _a;\n      const parse = (str2) => {\n        if (str2 === null) {\n          return null;\n        }\n        return JSON.parse(str2, options == null ? void 0 : options.reviver);\n      };\n      const str = (_a = storage.getItem(name)) != null ? _a : null;\n      if (str instanceof Promise) {\n        return str.then(parse);\n      }\n      return parse(str);\n    },\n    setItem: (name, newValue) => storage.setItem(\n      name,\n      JSON.stringify(newValue, options == null ? void 0 : options.replacer)\n    ),\n    removeItem: (name) => storage.removeItem(name)\n  };\n  return persistStorage;\n}\nconst toThenable = (fn) => (input) => {\n  try {\n    const result = fn(input);\n    if (result instanceof Promise) {\n      return result;\n    }\n    return {\n      then(onFulfilled) {\n        return toThenable(onFulfilled)(result);\n      },\n      catch(_onRejected) {\n        return this;\n      }\n    };\n  } catch (e) {\n    return {\n      then(_onFulfilled) {\n        return this;\n      },\n      catch(onRejected) {\n        return toThenable(onRejected)(e);\n      }\n    };\n  }\n};\nconst persistImpl = (config, baseOptions) => (set, get, api) => {\n  let options = {\n    storage: createJSONStorage(() => localStorage),\n    partialize: (state) => state,\n    version: 0,\n    merge: (persistedState, currentState) => ({\n      ...currentState,\n      ...persistedState\n    }),\n    ...baseOptions\n  };\n  let hasHydrated = false;\n  const hydrationListeners = /* @__PURE__ */ new Set();\n  const finishHydrationListeners = /* @__PURE__ */ new Set();\n  let storage = options.storage;\n  if (!storage) {\n    return config(\n      (...args) => {\n        console.warn(\n          `[zustand persist middleware] Unable to update item '${options.name}', the given storage is currently unavailable.`\n        );\n        set(...args);\n      },\n      get,\n      api\n    );\n  }\n  const setItem = () => {\n    const state = options.partialize({ ...get() });\n    return storage.setItem(options.name, {\n      state,\n      version: options.version\n    });\n  };\n  const savedSetState = api.setState;\n  api.setState = (state, replace) => {\n    savedSetState(state, replace);\n    void setItem();\n  };\n  const configResult = config(\n    (...args) => {\n      set(...args);\n      void setItem();\n    },\n    get,\n    api\n  );\n  api.getInitialState = () => configResult;\n  let stateFromStorage;\n  const hydrate = () => {\n    var _a, _b;\n    if (!storage) return;\n    hasHydrated = false;\n    hydrationListeners.forEach((cb) => {\n      var _a2;\n      return cb((_a2 = get()) != null ? _a2 : configResult);\n    });\n    const postRehydrationCallback = ((_b = options.onRehydrateStorage) == null ? void 0 : _b.call(options, (_a = get()) != null ? _a : configResult)) || void 0;\n    return toThenable(storage.getItem.bind(storage))(options.name).then((deserializedStorageValue) => {\n      if (deserializedStorageValue) {\n        if (typeof deserializedStorageValue.version === \"number\" && deserializedStorageValue.version !== options.version) {\n          if (options.migrate) {\n            return [\n              true,\n              options.migrate(\n                deserializedStorageValue.state,\n                deserializedStorageValue.version\n              )\n            ];\n          }\n          console.error(\n            `State loaded from storage couldn't be migrated since no migrate function was provided`\n          );\n        } else {\n          return [false, deserializedStorageValue.state];\n        }\n      }\n      return [false, void 0];\n    }).then((migrationResult) => {\n      var _a2;\n      const [migrated, migratedState] = migrationResult;\n      stateFromStorage = options.merge(\n        migratedState,\n        (_a2 = get()) != null ? _a2 : configResult\n      );\n      set(stateFromStorage, true);\n      if (migrated) {\n        return setItem();\n      }\n    }).then(() => {\n      postRehydrationCallback == null ? void 0 : postRehydrationCallback(stateFromStorage, void 0);\n      stateFromStorage = get();\n      hasHydrated = true;\n      finishHydrationListeners.forEach((cb) => cb(stateFromStorage));\n    }).catch((e) => {\n      postRehydrationCallback == null ? void 0 : postRehydrationCallback(void 0, e);\n    });\n  };\n  api.persist = {\n    setOptions: (newOptions) => {\n      options = {\n        ...options,\n        ...newOptions\n      };\n      if (newOptions.storage) {\n        storage = newOptions.storage;\n      }\n    },\n    clearStorage: () => {\n      storage == null ? void 0 : storage.removeItem(options.name);\n    },\n    getOptions: () => options,\n    rehydrate: () => hydrate(),\n    hasHydrated: () => hasHydrated,\n    onHydrate: (cb) => {\n      hydrationListeners.add(cb);\n      return () => {\n        hydrationListeners.delete(cb);\n      };\n    },\n    onFinishHydration: (cb) => {\n      finishHydrationListeners.add(cb);\n      return () => {\n        finishHydrationListeners.delete(cb);\n      };\n    }\n  };\n  if (!options.skipHydration) {\n    hydrate();\n  }\n  return stateFromStorage || configResult;\n};\nconst persist = persistImpl;\n\nexport { combine, createJSONStorage, devtools, persist, redux, subscribeWithSelector };\n","const createStoreImpl = (createState) => {\n  let state;\n  const listeners = /* @__PURE__ */ new Set();\n  const setState = (partial, replace) => {\n    const nextState = typeof partial === \"function\" ? partial(state) : partial;\n    if (!Object.is(nextState, state)) {\n      const previousState = state;\n      state = (replace != null ? replace : typeof nextState !== \"object\" || nextState === null) ? nextState : Object.assign({}, state, nextState);\n      listeners.forEach((listener) => listener(state, previousState));\n    }\n  };\n  const getState = () => state;\n  const getInitialState = () => initialState;\n  const subscribe = (listener) => {\n    listeners.add(listener);\n    return () => listeners.delete(listener);\n  };\n  const api = { setState, getState, getInitialState, subscribe };\n  const initialState = state = createState(setState, getState, api);\n  return api;\n};\nconst createStore = (createState) => createState ? createStoreImpl(createState) : createStoreImpl;\n\nexport { createStore };\n","\"use client\";\n\nimport { QueryClient, QueryClientProvider } from \"@tanstack/react-query\";\nimport { WagmiProvider } from \"wagmi\";\nimport { config } from \"./wagmi\";\nimport { useState } from \"react\";\n\nexport function Providers({ children }: { children: React.ReactNode }) {\n  const [queryClient] = useState(() => new QueryClient());\n\n  return (\n    <WagmiProvider config={config}>\n      <QueryClientProvider client={queryClient}>\n        {children}\n      </QueryClientProvider>\n    </WagmiProvider>\n  );\n}\n","// src/queryClient.ts\nimport {\n  functionalUpdate,\n  hashKey,\n  hashQueryKeyByOptions,\n  noop,\n  partialMatchKey,\n  resolveStaleTime,\n  skipToken\n} from \"./utils.js\";\nimport { QueryCache } from \"./queryCache.js\";\nimport { MutationCache } from \"./mutationCache.js\";\nimport { focusManager } from \"./focusManager.js\";\nimport { onlineManager } from \"./onlineManager.js\";\nimport { notifyManager } from \"./notifyManager.js\";\nimport { infiniteQueryBehavior } from \"./infiniteQueryBehavior.js\";\nvar QueryClient = class {\n  #queryCache;\n  #mutationCache;\n  #defaultOptions;\n  #queryDefaults;\n  #mutationDefaults;\n  #mountCount;\n  #unsubscribeFocus;\n  #unsubscribeOnline;\n  constructor(config = {}) {\n    this.#queryCache = config.queryCache || new QueryCache();\n    this.#mutationCache = config.mutationCache || new MutationCache();\n    this.#defaultOptions = config.defaultOptions || {};\n    this.#queryDefaults = /* @__PURE__ */ new Map();\n    this.#mutationDefaults = /* @__PURE__ */ new Map();\n    this.#mountCount = 0;\n  }\n  mount() {\n    this.#mountCount++;\n    if (this.#mountCount !== 1) return;\n    this.#unsubscribeFocus = focusManager.subscribe(async (focused) => {\n      if (focused) {\n        await this.resumePausedMutations();\n        this.#queryCache.onFocus();\n      }\n    });\n    this.#unsubscribeOnline = onlineManager.subscribe(async (online) => {\n      if (online) {\n        await this.resumePausedMutations();\n        this.#queryCache.onOnline();\n      }\n    });\n  }\n  unmount() {\n    this.#mountCount--;\n    if (this.#mountCount !== 0) return;\n    this.#unsubscribeFocus?.();\n    this.#unsubscribeFocus = void 0;\n    this.#unsubscribeOnline?.();\n    this.#unsubscribeOnline = void 0;\n  }\n  isFetching(filters) {\n    return this.#queryCache.findAll({ ...filters, fetchStatus: \"fetching\" }).length;\n  }\n  isMutating(filters) {\n    return this.#mutationCache.findAll({ ...filters, status: \"pending\" }).length;\n  }\n  /**\n   * Imperative (non-reactive) way to retrieve data for a QueryKey.\n   * Should only be used in callbacks or functions where reading the latest data is necessary, e.g. for optimistic updates.\n   *\n   * Hint: Do not use this function inside a component, because it won't receive updates.\n   * Use `useQuery` to create a `QueryObserver` that subscribes to changes.\n   */\n  getQueryData(queryKey) {\n    const options = this.defaultQueryOptions({ queryKey });\n    return this.#queryCache.get(options.queryHash)?.state.data;\n  }\n  ensureQueryData(options) {\n    const defaultedOptions = this.defaultQueryOptions(options);\n    const query = this.#queryCache.build(this, defaultedOptions);\n    const cachedData = query.state.data;\n    if (cachedData === void 0) {\n      return this.fetchQuery(options);\n    }\n    if (options.revalidateIfStale && query.isStaleByTime(resolveStaleTime(defaultedOptions.staleTime, query))) {\n      void this.prefetchQuery(defaultedOptions);\n    }\n    return Promise.resolve(cachedData);\n  }\n  getQueriesData(filters) {\n    return this.#queryCache.findAll(filters).map(({ queryKey, state }) => {\n      const data = state.data;\n      return [queryKey, data];\n    });\n  }\n  setQueryData(queryKey, updater, options) {\n    const defaultedOptions = this.defaultQueryOptions({ queryKey });\n    const query = this.#queryCache.get(\n      defaultedOptions.queryHash\n    );\n    const prevData = query?.state.data;\n    const data = functionalUpdate(updater, prevData);\n    if (data === void 0) {\n      return void 0;\n    }\n    return this.#queryCache.build(this, defaultedOptions).setData(data, { ...options, manual: true });\n  }\n  setQueriesData(filters, updater, options) {\n    return notifyManager.batch(\n      () => this.#queryCache.findAll(filters).map(({ queryKey }) => [\n        queryKey,\n        this.setQueryData(queryKey, updater, options)\n      ])\n    );\n  }\n  getQueryState(queryKey) {\n    const options = this.defaultQueryOptions({ queryKey });\n    return this.#queryCache.get(\n      options.queryHash\n    )?.state;\n  }\n  removeQueries(filters) {\n    const queryCache = this.#queryCache;\n    notifyManager.batch(() => {\n      queryCache.findAll(filters).forEach((query) => {\n        queryCache.remove(query);\n      });\n    });\n  }\n  resetQueries(filters, options) {\n    const queryCache = this.#queryCache;\n    return notifyManager.batch(() => {\n      queryCache.findAll(filters).forEach((query) => {\n        query.reset();\n      });\n      return this.refetchQueries(\n        {\n          type: \"active\",\n          ...filters\n        },\n        options\n      );\n    });\n  }\n  cancelQueries(filters, cancelOptions = {}) {\n    const defaultedCancelOptions = { revert: true, ...cancelOptions };\n    const promises = notifyManager.batch(\n      () => this.#queryCache.findAll(filters).map((query) => query.cancel(defaultedCancelOptions))\n    );\n    return Promise.all(promises).then(noop).catch(noop);\n  }\n  invalidateQueries(filters, options = {}) {\n    return notifyManager.batch(() => {\n      this.#queryCache.findAll(filters).forEach((query) => {\n        query.invalidate();\n      });\n      if (filters?.refetchType === \"none\") {\n        return Promise.resolve();\n      }\n      return this.refetchQueries(\n        {\n          ...filters,\n          type: filters?.refetchType ?? filters?.type ?? \"active\"\n        },\n        options\n      );\n    });\n  }\n  refetchQueries(filters, options = {}) {\n    const fetchOptions = {\n      ...options,\n      cancelRefetch: options.cancelRefetch ?? true\n    };\n    const promises = notifyManager.batch(\n      () => this.#queryCache.findAll(filters).filter((query) => !query.isDisabled() && !query.isStatic()).map((query) => {\n        let promise = query.fetch(void 0, fetchOptions);\n        if (!fetchOptions.throwOnError) {\n          promise = promise.catch(noop);\n        }\n        return query.state.fetchStatus === \"paused\" ? Promise.resolve() : promise;\n      })\n    );\n    return Promise.all(promises).then(noop);\n  }\n  fetchQuery(options) {\n    const defaultedOptions = this.defaultQueryOptions(options);\n    if (defaultedOptions.retry === void 0) {\n      defaultedOptions.retry = false;\n    }\n    const query = this.#queryCache.build(this, defaultedOptions);\n    return query.isStaleByTime(\n      resolveStaleTime(defaultedOptions.staleTime, query)\n    ) ? query.fetch(defaultedOptions) : Promise.resolve(query.state.data);\n  }\n  prefetchQuery(options) {\n    return this.fetchQuery(options).then(noop).catch(noop);\n  }\n  fetchInfiniteQuery(options) {\n    options.behavior = infiniteQueryBehavior(options.pages);\n    return this.fetchQuery(options);\n  }\n  prefetchInfiniteQuery(options) {\n    return this.fetchInfiniteQuery(options).then(noop).catch(noop);\n  }\n  ensureInfiniteQueryData(options) {\n    options.behavior = infiniteQueryBehavior(options.pages);\n    return this.ensureQueryData(options);\n  }\n  resumePausedMutations() {\n    if (onlineManager.isOnline()) {\n      return this.#mutationCache.resumePausedMutations();\n    }\n    return Promise.resolve();\n  }\n  getQueryCache() {\n    return this.#queryCache;\n  }\n  getMutationCache() {\n    return this.#mutationCache;\n  }\n  getDefaultOptions() {\n    return this.#defaultOptions;\n  }\n  setDefaultOptions(options) {\n    this.#defaultOptions = options;\n  }\n  setQueryDefaults(queryKey, options) {\n    this.#queryDefaults.set(hashKey(queryKey), {\n      queryKey,\n      defaultOptions: options\n    });\n  }\n  getQueryDefaults(queryKey) {\n    const defaults = [...this.#queryDefaults.values()];\n    const result = {};\n    defaults.forEach((queryDefault) => {\n      if (partialMatchKey(queryKey, queryDefault.queryKey)) {\n        Object.assign(result, queryDefault.defaultOptions);\n      }\n    });\n    return result;\n  }\n  setMutationDefaults(mutationKey, options) {\n    this.#mutationDefaults.set(hashKey(mutationKey), {\n      mutationKey,\n      defaultOptions: options\n    });\n  }\n  getMutationDefaults(mutationKey) {\n    const defaults = [...this.#mutationDefaults.values()];\n    const result = {};\n    defaults.forEach((queryDefault) => {\n      if (partialMatchKey(mutationKey, queryDefault.mutationKey)) {\n        Object.assign(result, queryDefault.defaultOptions);\n      }\n    });\n    return result;\n  }\n  defaultQueryOptions(options) {\n    if (options._defaulted) {\n      return options;\n    }\n    const defaultedOptions = {\n      ...this.#defaultOptions.queries,\n      ...this.getQueryDefaults(options.queryKey),\n      ...options,\n      _defaulted: true\n    };\n    if (!defaultedOptions.queryHash) {\n      defaultedOptions.queryHash = hashQueryKeyByOptions(\n        defaultedOptions.queryKey,\n        defaultedOptions\n      );\n    }\n    if (defaultedOptions.refetchOnReconnect === void 0) {\n      defaultedOptions.refetchOnReconnect = defaultedOptions.networkMode !== \"always\";\n    }\n    if (defaultedOptions.throwOnError === void 0) {\n      defaultedOptions.throwOnError = !!defaultedOptions.suspense;\n    }\n    if (!defaultedOptions.networkMode && defaultedOptions.persister) {\n      defaultedOptions.networkMode = \"offlineFirst\";\n    }\n    if (defaultedOptions.queryFn === skipToken) {\n      defaultedOptions.enabled = false;\n    }\n    return defaultedOptions;\n  }\n  defaultMutationOptions(options) {\n    if (options?._defaulted) {\n      return options;\n    }\n    return {\n      ...this.#defaultOptions.mutations,\n      ...options?.mutationKey && this.getMutationDefaults(options.mutationKey),\n      ...options,\n      _defaulted: true\n    };\n  }\n  clear() {\n    this.#queryCache.clear();\n    this.#mutationCache.clear();\n  }\n};\nexport {\n  QueryClient\n};\n//# sourceMappingURL=queryClient.js.map","const size = 256\nlet index = size\nlet buffer: string\n\nexport function uid(length = 11) {\n  if (!buffer || index + length > size * 2) {\n    buffer = ''\n    index = 0\n    for (let i = 0; i < size; i++) {\n      buffer += ((256 + Math.random() * 256) | 0).toString(16).substring(1)\n    }\n  }\n  return buffer.substring(index, index++ + length)\n}\n","import type { Chain, Transport } from 'viem'\n\ntype ExtractRpcUrlsParameters = {\n  transports?: Record<string, Transport> | undefined\n  chain: Chain\n}\n\nexport function extractRpcUrls(parameters: ExtractRpcUrlsParameters) {\n  const { chain } = parameters\n  const fallbackUrl = chain.rpcUrls.default.http[0]\n\n  if (!parameters.transports) return [fallbackUrl]\n\n  const transport = parameters.transports?.[chain.id]?.({ chain })\n  const transports = (transport?.value?.transports as NonNullable<\n    typeof transport\n  >[]) || [transport]\n  return transports.map(({ value }) => value?.url || fallbackUrl)\n}\n","type Reviver = (key: string, value: any) => any\n\nexport function deserialize<type>(value: string, reviver?: Reviver): type {\n  return JSON.parse(value, (key, value_) => {\n    let value = value_\n    if (value?.__type === 'bigint') value = BigInt(value.value)\n    if (value?.__type === 'Map') value = new Map(value.value)\n    return reviver?.(key, value) ?? value\n  })\n}\n","import {\n  ChainNotConfiguredError,\n  type Connector,\n  createConnector,\n  extractRpcUrls,\n  ProviderNotFoundError,\n} from '@wagmi/core'\nimport type { Compute, ExactPartial, Omit } from '@wagmi/core/internal'\nimport type { EthereumProvider } from '@walletconnect/ethereum-provider'\nimport {\n  type AddEthereumChainParameter,\n  type Address,\n  getAddress,\n  numberToHex,\n  type ProviderConnectInfo,\n  type ProviderRpcError,\n  type RpcError,\n  SwitchChainError,\n  UserRejectedRequestError,\n} from 'viem'\n\ntype WalletConnectConnector = Connector & {\n  onDisplayUri(uri: string): void\n  onSessionDelete(data: { topic: string }): void\n}\n\ntype EthereumProviderOptions = Parameters<(typeof EthereumProvider)['init']>[0]\n\nexport type WalletConnectParameters = Compute<\n  {\n    /**\n     * If a new chain is added to a previously existing configured connector `chains`, this flag\n     * will determine if that chain should be considered as stale. A stale chain is a chain that\n     * WalletConnect has yet to establish a relationship with (e.g. the user has not approved or\n     * rejected the chain).\n     *\n     * This flag mainly affects the behavior when a wallet does not support dynamic chain authorization\n     * with WalletConnect v2.\n     *\n     * If `true` (default), the new chain will be treated as a stale chain. If the user\n     * has yet to establish a relationship (approved/rejected) with this chain in their WalletConnect\n     * session, the connector will disconnect upon the dapp auto-connecting, and the user will have to\n     * reconnect to the dapp (revalidate the chain) in order to approve the newly added chain.\n     * This is the default behavior to avoid an unexpected error upon switching chains which may\n     * be a confusing user experience (e.g. the user will not know they have to reconnect\n     * unless the dapp handles these types of errors).\n     *\n     * If `false`, the new chain will be treated as a potentially valid chain. This means that if the user\n     * has yet to establish a relationship with the chain in their WalletConnect session, wagmi will successfully\n     * auto-connect the user. This comes with the trade-off that the connector will throw an error\n     * when attempting to switch to the unapproved chain if the wallet does not support dynamic session updates.\n     * This may be useful in cases where a dapp constantly\n     * modifies their configured chains, and they do not want to disconnect the user upon\n     * auto-connecting. If the user decides to switch to the unapproved chain, it is important that the\n     * dapp handles this error and prompts the user to reconnect to the dapp in order to approve\n     * the newly added chain.\n     *\n     * @default true\n     */\n    isNewChainsStale?: boolean\n  } & Omit<\n    EthereumProviderOptions,\n    | 'chains'\n    | 'events'\n    | 'optionalChains'\n    | 'optionalEvents'\n    | 'optionalMethods'\n    | 'methods'\n    | 'rpcMap'\n    | 'showQrModal'\n  > &\n    ExactPartial<Pick<EthereumProviderOptions, 'showQrModal'>>\n>\n\nwalletConnect.type = 'walletConnect' as const\n/**\n * @deprecated **NOTE: This connector uses a vulnerable dependency downstream** (`@walletconnect/ethereum-provider@2.21.1` > `@reown/appkit@1.8.9` > `@reown/appkit-utils@1.8.9` > `@walletconnect/logger@2.1.2` > `pino@7.11.0`). You should override `pino` to a secure version via your package manager:\n *\n * ### npm\n * ```json\n * {\n *   \"overrides\": {\n *     \"@walletconnect/logger\": {\n *       \"pino\": \"10.0.0\"\n *     }\n *   }\n * }\n * ```\n *\n * ### pnpm\n * ```json\n * {\n *   \"pnpm\": {\n *     \"overrides\": {\n *       \"@walletconnect/logger>pino\": \"10.0.0\"\n *     }\n *   }\n * }\n * ```\n *\n * ### yarn\n * ```json\n * {\n *   \"resolutions\": {\n *     \"@walletconnect/logger/pino\": \"10.0.0\"\n *   }\n * }\n * ```\n *\n * ### bun\n * ```json\n * {\n *   \"overrides\": {\n *     \"@walletconnect/logger\": {\n *       \"pino\": \"10.0.0\"\n *     }\n *   }\n * }\n * ```\n *\n * Normally the Wagmi team would upgrade `@walletconnect/ethereum-provider` to a fixed version for you, but `@walletconnect/ethereum-provider` was relicensed recently from Apache to a [non-permissive license](https://github.com/reown-com/appkit/blob/main/LICENSE.md). We are trying to get the WalletConnect team to release a version that closes the vulnerability under the old Apache license.\n */\nexport function walletConnect(parameters: WalletConnectParameters) {\n  const isNewChainsStale = parameters.isNewChainsStale ?? true\n\n  type Provider = Awaited<ReturnType<(typeof EthereumProvider)['init']>>\n  type Properties = {\n    // TODO(v3): Make `withCapabilities: true` default behavior\n    connect<withCapabilities extends boolean = false>(parameters?: {\n      chainId?: number | undefined\n      isReconnecting?: boolean | undefined\n      pairingTopic?: string | undefined\n      withCapabilities?: withCapabilities | boolean | undefined\n    }): Promise<{\n      accounts: withCapabilities extends true\n        ? readonly { address: Address }[]\n        : readonly Address[]\n      chainId: number\n    }>\n    getNamespaceChainsIds(): number[]\n    getRequestedChainsIds(): Promise<number[]>\n    isChainsStale(): Promise<boolean>\n    onConnect(connectInfo: ProviderConnectInfo): void\n    onDisplayUri(uri: string): void\n    onSessionDelete(data: { topic: string }): void\n    setRequestedChainsIds(chains: number[]): void\n    requestedChainsStorageKey: `${string}.requestedChains`\n  }\n  type StorageItem = {\n    [_ in Properties['requestedChainsStorageKey']]: number[]\n  }\n\n  let provider_: Provider | undefined\n  let providerPromise: Promise<typeof provider_>\n  const NAMESPACE = 'eip155'\n\n  let accountsChanged: WalletConnectConnector['onAccountsChanged'] | undefined\n  let chainChanged: WalletConnectConnector['onChainChanged'] | undefined\n  let connect: WalletConnectConnector['onConnect'] | undefined\n  let displayUri: WalletConnectConnector['onDisplayUri'] | undefined\n  let sessionDelete: WalletConnectConnector['onSessionDelete'] | undefined\n  let disconnect: WalletConnectConnector['onDisconnect'] | undefined\n\n  return createConnector<Provider, Properties, StorageItem>((config) => ({\n    id: 'walletConnect',\n    name: 'WalletConnect',\n    type: walletConnect.type,\n    async setup() {\n      const provider = await this.getProvider().catch(() => null)\n      if (!provider) return\n      if (!connect) {\n        connect = this.onConnect.bind(this)\n        provider.on('connect', connect)\n      }\n      if (!sessionDelete) {\n        sessionDelete = this.onSessionDelete.bind(this)\n        provider.on('session_delete', sessionDelete)\n      }\n    },\n    async connect({ chainId, withCapabilities, ...rest } = {}) {\n      try {\n        const provider = await this.getProvider()\n        if (!provider) throw new ProviderNotFoundError()\n        if (!displayUri) {\n          displayUri = this.onDisplayUri\n          provider.on('display_uri', displayUri)\n        }\n\n        let targetChainId = chainId\n        if (!targetChainId) {\n          const state = (await config.storage?.getItem('state')) ?? {}\n          const isChainSupported = config.chains.some(\n            (x) => x.id === state.chainId,\n          )\n          if (isChainSupported) targetChainId = state.chainId\n          else targetChainId = config.chains[0]?.id\n        }\n        if (!targetChainId) throw new Error('No chains found on connector.')\n\n        const isChainsStale = await this.isChainsStale()\n        // If there is an active session with stale chains, disconnect current session.\n        if (provider.session && isChainsStale) await provider.disconnect()\n\n        // If there isn't an active session or chains are stale, connect.\n        if (!provider.session || isChainsStale) {\n          const optionalChains = config.chains\n            .filter((chain) => chain.id !== targetChainId)\n            .map((optionalChain) => optionalChain.id)\n          await provider.connect({\n            optionalChains: [targetChainId, ...optionalChains],\n            ...('pairingTopic' in rest\n              ? { pairingTopic: rest.pairingTopic }\n              : {}),\n          })\n\n          this.setRequestedChainsIds(config.chains.map((x) => x.id))\n        }\n\n        // If session exists and chains are authorized, enable provider for required chain\n        const accounts = (await provider.enable()).map((x) => getAddress(x))\n\n        // Switch to chain if provided\n        let currentChainId = await this.getChainId()\n        if (chainId && currentChainId !== chainId) {\n          const chain = await this.switchChain!({ chainId }).catch(\n            (error: RpcError) => {\n              if (\n                error.code === UserRejectedRequestError.code &&\n                (error.cause as RpcError | undefined)?.message !==\n                  'Missing or invalid. request() method: wallet_addEthereumChain'\n              )\n                throw error\n              return { id: currentChainId }\n            },\n          )\n          currentChainId = chain?.id ?? currentChainId\n        }\n\n        if (displayUri) {\n          provider.removeListener('display_uri', displayUri)\n          displayUri = undefined\n        }\n        if (connect) {\n          provider.removeListener('connect', connect)\n          connect = undefined\n        }\n        if (!accountsChanged) {\n          accountsChanged = this.onAccountsChanged.bind(this)\n          provider.on('accountsChanged', accountsChanged)\n        }\n        if (!chainChanged) {\n          chainChanged = this.onChainChanged.bind(this)\n          provider.on('chainChanged', chainChanged)\n        }\n        if (!disconnect) {\n          disconnect = this.onDisconnect.bind(this)\n          provider.on('disconnect', disconnect)\n        }\n        if (!sessionDelete) {\n          sessionDelete = this.onSessionDelete.bind(this)\n          provider.on('session_delete', sessionDelete)\n        }\n\n        return {\n          accounts: (withCapabilities\n            ? accounts.map((address) => ({ address, capabilities: {} }))\n            : accounts) as never,\n          chainId: currentChainId,\n        }\n      } catch (error) {\n        if (\n          /(user rejected|connection request reset)/i.test(\n            (error as ProviderRpcError)?.message,\n          )\n        ) {\n          throw new UserRejectedRequestError(error as Error)\n        }\n        throw error\n      }\n    },\n    async disconnect() {\n      const provider = await this.getProvider()\n      try {\n        await provider?.disconnect()\n      } catch (error) {\n        if (!/No matching key/i.test((error as Error).message)) throw error\n      } finally {\n        if (chainChanged) {\n          provider?.removeListener('chainChanged', chainChanged)\n          chainChanged = undefined\n        }\n        if (disconnect) {\n          provider?.removeListener('disconnect', disconnect)\n          disconnect = undefined\n        }\n        if (!connect) {\n          connect = this.onConnect.bind(this)\n          provider?.on('connect', connect)\n        }\n        if (accountsChanged) {\n          provider?.removeListener('accountsChanged', accountsChanged)\n          accountsChanged = undefined\n        }\n        if (sessionDelete) {\n          provider?.removeListener('session_delete', sessionDelete)\n          sessionDelete = undefined\n        }\n\n        this.setRequestedChainsIds([])\n      }\n    },\n    async getAccounts() {\n      const provider = await this.getProvider()\n      return provider.accounts.map((x) => getAddress(x))\n    },\n    async getProvider({ chainId } = {}) {\n      async function initProvider() {\n        const optionalChains = config.chains.map((x) => x.id) as [number]\n        if (!optionalChains.length) return\n        const { EthereumProvider } = await import(\n          '@walletconnect/ethereum-provider'\n        )\n        return await EthereumProvider.init({\n          ...parameters,\n          disableProviderPing: true,\n          optionalChains,\n          projectId: parameters.projectId,\n          rpcMap: Object.fromEntries(\n            config.chains.map((chain) => {\n              const [url] = extractRpcUrls({\n                chain,\n                transports: config.transports,\n              })\n              return [chain.id, url]\n            }),\n          ),\n          showQrModal: parameters.showQrModal ?? true,\n        })\n      }\n\n      if (!provider_) {\n        if (!providerPromise) providerPromise = initProvider()\n        provider_ = await providerPromise\n        provider_?.events.setMaxListeners(Number.POSITIVE_INFINITY)\n      }\n      if (chainId) await this.switchChain?.({ chainId })\n      return provider_!\n    },\n    async getChainId() {\n      const provider = await this.getProvider()\n      return provider.chainId\n    },\n    async isAuthorized() {\n      try {\n        const [accounts, provider] = await Promise.all([\n          this.getAccounts(),\n          this.getProvider(),\n        ])\n\n        // If an account does not exist on the session, then the connector is unauthorized.\n        if (!accounts.length) return false\n\n        // If the chains are stale on the session, then the connector is unauthorized.\n        const isChainsStale = await this.isChainsStale()\n        if (isChainsStale && provider.session) {\n          await provider.disconnect().catch(() => {})\n          return false\n        }\n        return true\n      } catch {\n        return false\n      }\n    },\n    async switchChain({ addEthereumChainParameter, chainId }) {\n      const provider = await this.getProvider()\n      if (!provider) throw new ProviderNotFoundError()\n\n      const chain = config.chains.find((x) => x.id === chainId)\n      if (!chain) throw new SwitchChainError(new ChainNotConfiguredError())\n\n      try {\n        await Promise.all([\n          new Promise<void>((resolve) => {\n            const listener = ({\n              chainId: currentChainId,\n            }: {\n              chainId?: number | undefined\n            }) => {\n              if (currentChainId === chainId) {\n                config.emitter.off('change', listener)\n                resolve()\n              }\n            }\n            config.emitter.on('change', listener)\n          }),\n          provider.request({\n            method: 'wallet_switchEthereumChain',\n            params: [{ chainId: numberToHex(chainId) }],\n          }),\n        ])\n\n        const requestedChains = await this.getRequestedChainsIds()\n        this.setRequestedChainsIds([...requestedChains, chainId])\n\n        return chain\n      } catch (err) {\n        const error = err as RpcError\n\n        if (/(user rejected)/i.test(error.message))\n          throw new UserRejectedRequestError(error)\n\n        // Indicates chain is not added to provider\n        try {\n          let blockExplorerUrls: string[] | undefined\n          if (addEthereumChainParameter?.blockExplorerUrls)\n            blockExplorerUrls = addEthereumChainParameter.blockExplorerUrls\n          else\n            blockExplorerUrls = chain.blockExplorers?.default.url\n              ? [chain.blockExplorers?.default.url]\n              : []\n\n          let rpcUrls: readonly string[]\n          if (addEthereumChainParameter?.rpcUrls?.length)\n            rpcUrls = addEthereumChainParameter.rpcUrls\n          else rpcUrls = [...chain.rpcUrls.default.http]\n\n          const addEthereumChain = {\n            blockExplorerUrls,\n            chainId: numberToHex(chainId),\n            chainName: addEthereumChainParameter?.chainName ?? chain.name,\n            iconUrls: addEthereumChainParameter?.iconUrls,\n            nativeCurrency:\n              addEthereumChainParameter?.nativeCurrency ?? chain.nativeCurrency,\n            rpcUrls,\n          } satisfies AddEthereumChainParameter\n\n          await provider.request({\n            method: 'wallet_addEthereumChain',\n            params: [addEthereumChain],\n          })\n\n          const requestedChains = await this.getRequestedChainsIds()\n          this.setRequestedChainsIds([...requestedChains, chainId])\n          return chain\n        } catch (error) {\n          throw new UserRejectedRequestError(error as Error)\n        }\n      }\n    },\n    onAccountsChanged(accounts) {\n      if (accounts.length === 0) this.onDisconnect()\n      else\n        config.emitter.emit('change', {\n          accounts: accounts.map((x) => getAddress(x)),\n        })\n    },\n    onChainChanged(chain) {\n      const chainId = Number(chain)\n      config.emitter.emit('change', { chainId })\n    },\n    async onConnect(connectInfo) {\n      const chainId = Number(connectInfo.chainId)\n      const accounts = await this.getAccounts()\n      config.emitter.emit('connect', { accounts, chainId })\n    },\n    async onDisconnect(_error) {\n      this.setRequestedChainsIds([])\n      config.emitter.emit('disconnect')\n\n      const provider = await this.getProvider()\n      if (accountsChanged) {\n        provider.removeListener('accountsChanged', accountsChanged)\n        accountsChanged = undefined\n      }\n      if (chainChanged) {\n        provider.removeListener('chainChanged', chainChanged)\n        chainChanged = undefined\n      }\n      if (disconnect) {\n        provider.removeListener('disconnect', disconnect)\n        disconnect = undefined\n      }\n      if (sessionDelete) {\n        provider.removeListener('session_delete', sessionDelete)\n        sessionDelete = undefined\n      }\n      if (!connect) {\n        connect = this.onConnect.bind(this)\n        provider.on('connect', connect)\n      }\n    },\n    onDisplayUri(uri) {\n      config.emitter.emit('message', { type: 'display_uri', data: uri })\n    },\n    onSessionDelete() {\n      this.onDisconnect()\n    },\n    getNamespaceChainsIds() {\n      if (!provider_) return []\n      const chainIds = provider_.session?.namespaces[NAMESPACE]?.accounts?.map(\n        (account) => Number.parseInt(account.split(':')[1] || '', 10),\n      )\n      return chainIds ?? []\n    },\n    async getRequestedChainsIds() {\n      return (\n        (await config.storage?.getItem(this.requestedChainsStorageKey)) ?? []\n      )\n    },\n    /**\n     * Checks if the target chains match the chains that were\n     * initially requested by the connector for the WalletConnect session.\n     * If there is a mismatch, this means that the chains on the connector\n     * are considered stale, and need to be revalidated at a later point (via\n     * connection).\n     *\n     * There may be a scenario where a dapp adds a chain to the\n     * connector later on, however, this chain will not have been approved or rejected\n     * by the wallet. In this case, the chain is considered stale.\n     */\n    async isChainsStale() {\n      if (!isNewChainsStale) return false\n\n      const connectorChains = config.chains.map((x) => x.id)\n      const namespaceChains = this.getNamespaceChainsIds()\n      if (\n        namespaceChains.length &&\n        !namespaceChains.some((id) => connectorChains.includes(id))\n      )\n        return false\n\n      const requestedChains = await this.getRequestedChainsIds()\n      return !connectorChains.every((id) => requestedChains.includes(id))\n    },\n    async setRequestedChainsIds(chains) {\n      await config.storage?.setItem(this.requestedChainsStorageKey, chains)\n    },\n    get requestedChainsStorageKey() {\n      return `${this.id}.requestedChains` as Properties['requestedChainsStorageKey']\n    },\n  }))\n}\n","import {\n  createStore as createMipd,\n  type EIP6963ProviderDetail,\n  type Store as MipdStore,\n} from 'mipd'\nimport {\n  type Address,\n  type Chain,\n  type Client,\n  createClient,\n  type EIP1193RequestFn,\n  type ClientConfig as viem_ClientConfig,\n  type Transport as viem_Transport,\n} from 'viem'\nimport { persist, subscribeWithSelector } from 'zustand/middleware'\nimport { createStore, type Mutate, type StoreApi } from 'zustand/vanilla'\n\nimport type {\n  ConnectorEventMap,\n  CreateConnectorFn,\n} from './connectors/createConnector.js'\nimport { injected } from './connectors/injected.js'\nimport { createEmitter, type Emitter, type EventData } from './createEmitter.js'\nimport {\n  createStorage,\n  getDefaultStorage,\n  type Storage,\n} from './createStorage.js'\nimport { ChainNotConfiguredError } from './errors/config.js'\nimport type {\n  Compute,\n  ExactPartial,\n  LooseOmit,\n  OneOf,\n  RemoveUndefined,\n} from './types/utils.js'\nimport { uid } from './utils/uid.js'\nimport { version } from './version.js'\n\nexport function createConfig<\n  const chains extends readonly [Chain, ...Chain[]],\n  transports extends Record<chains[number]['id'], Transport>,\n  const connectorFns extends readonly CreateConnectorFn[],\n>(\n  parameters: CreateConfigParameters<chains, transports, connectorFns>,\n): Config<chains, transports, connectorFns> {\n  const {\n    multiInjectedProviderDiscovery = true,\n    storage = createStorage({\n      storage: getDefaultStorage(),\n    }),\n    syncConnectedChain = true,\n    ssr = false,\n    ...rest\n  } = parameters\n\n  /////////////////////////////////////////////////////////////////////////////////////////////////\n  // Set up connectors, clients, etc.\n  /////////////////////////////////////////////////////////////////////////////////////////////////\n\n  const mipd =\n    typeof window !== 'undefined' && multiInjectedProviderDiscovery\n      ? createMipd()\n      : undefined\n\n  const chains = createStore(() => rest.chains)\n  const connectors = createStore(() => {\n    const collection = []\n    const rdnsSet = new Set<string>()\n    for (const connectorFns of rest.connectors ?? []) {\n      const connector = setup(connectorFns)\n      collection.push(connector)\n      if (!ssr && connector.rdns) {\n        const rdnsValues =\n          typeof connector.rdns === 'string' ? [connector.rdns] : connector.rdns\n        for (const rdns of rdnsValues) {\n          rdnsSet.add(rdns)\n        }\n      }\n    }\n    if (!ssr && mipd) {\n      const providers = mipd.getProviders()\n      for (const provider of providers) {\n        if (rdnsSet.has(provider.info.rdns)) continue\n        collection.push(setup(providerDetailToConnector(provider)))\n      }\n    }\n    return collection\n  })\n  function setup(connectorFn: CreateConnectorFn): Connector {\n    // Set up emitter with uid and add to connector so they are \"linked\" together.\n    const emitter = createEmitter<ConnectorEventMap>(uid())\n    const connector = {\n      ...connectorFn({\n        emitter,\n        chains: chains.getState(),\n        storage,\n        transports: rest.transports,\n      }),\n      emitter,\n      uid: emitter.uid,\n    }\n\n    // Start listening for `connect` events on connector setup\n    // This allows connectors to \"connect\" themselves without user interaction (e.g. MetaMask's \"Manually connect to current site\")\n    emitter.on('connect', connect)\n    connector.setup?.()\n\n    return connector\n  }\n  function providerDetailToConnector(providerDetail: EIP6963ProviderDetail) {\n    const { info } = providerDetail\n    const provider = providerDetail.provider as any\n    return injected({ target: { ...info, id: info.rdns, provider } })\n  }\n\n  const clients = new Map<number, Client<Transport, chains[number]>>()\n  function getClient<chainId extends chains[number]['id']>(\n    config: { chainId?: chainId | chains[number]['id'] | undefined } = {},\n  ): Client<Transport, Extract<chains[number], { id: chainId }>> {\n    const chainId = config.chainId ?? store.getState().chainId\n    const chain = chains.getState().find((x) => x.id === chainId)\n\n    // chainId specified and not configured\n    if (config.chainId && !chain) throw new ChainNotConfiguredError()\n\n    // If the target chain is not configured, use the client of the current chain.\n    type Return = Client<Transport, Extract<chains[number], { id: chainId }>>\n    {\n      const client = clients.get(store.getState().chainId)\n      if (client && !chain) return client as Return\n      if (!chain) throw new ChainNotConfiguredError()\n    }\n\n    // If a memoized client exists for a chain id, use that.\n    {\n      const client = clients.get(chainId)\n      if (client) return client as Return\n    }\n\n    let client: Client<Transport, chains[number]>\n    if (rest.client) client = rest.client({ chain })\n    else {\n      const chainId = chain.id as chains[number]['id']\n      const chainIds = chains.getState().map((x) => x.id)\n      // Grab all properties off `rest` and resolve for use in `createClient`\n      const properties: Partial<viem_ClientConfig> = {}\n      const entries = Object.entries(rest) as [keyof typeof rest, any][]\n\n      for (const [key, value] of entries) {\n        if (\n          key === 'chains' ||\n          key === 'client' ||\n          key === 'connectors' ||\n          key === 'transports'\n        )\n          continue\n\n        if (typeof value === 'object') {\n          // check if value is chainId-specific since some values can be objects\n          // e.g. { batch: { multicall: { batchSize: 1024 } } }\n          if (chainId in value) properties[key] = value[chainId]\n          else {\n            // check if value is chainId-specific, but does not have value for current chainId\n            const hasChainSpecificValue = chainIds.some((x) => x in value)\n            if (hasChainSpecificValue) continue\n            properties[key] = value\n          }\n        } else properties[key] = value\n      }\n\n      client = createClient({\n        ...properties,\n        chain,\n        batch: properties.batch ?? { multicall: true },\n        transport: (parameters) =>\n          rest.transports[chainId]({ ...parameters, connectors }),\n      })\n    }\n\n    clients.set(chainId, client)\n    return client as Return\n  }\n\n  /////////////////////////////////////////////////////////////////////////////////////////////////\n  // Create store\n  /////////////////////////////////////////////////////////////////////////////////////////////////\n\n  function getInitialState(): State {\n    return {\n      chainId: chains.getState()[0].id,\n      connections: new Map<string, Connection>(),\n      current: null,\n      status: 'disconnected',\n    }\n  }\n\n  let currentVersion: number\n  const prefix = '0.0.0-canary-'\n  if (version.startsWith(prefix))\n    currentVersion = Number.parseInt(version.replace(prefix, ''), 10)\n  // use package major version to version store\n  else currentVersion = Number.parseInt(version.split('.')[0] ?? '0', 10)\n\n  const store = createStore(\n    subscribeWithSelector(\n      // only use persist middleware if storage exists\n      storage\n        ? persist(getInitialState, {\n            migrate(persistedState, version) {\n              if (version === currentVersion) return persistedState as State\n\n              const initialState = getInitialState()\n              const chainId = validatePersistedChainId(\n                persistedState,\n                initialState.chainId,\n              )\n              return { ...initialState, chainId }\n            },\n            name: 'store',\n            partialize(state) {\n              // Only persist \"critical\" store properties to preserve storage size.\n              return {\n                connections: {\n                  __type: 'Map',\n                  value: Array.from(state.connections.entries()).map(\n                    ([key, connection]) => {\n                      const { id, name, type, uid } = connection.connector\n                      const connector = { id, name, type, uid }\n                      return [key, { ...connection, connector }]\n                    },\n                  ),\n                } as unknown as PartializedState['connections'],\n                chainId: state.chainId,\n                current: state.current,\n              } satisfies PartializedState\n            },\n            merge(persistedState, currentState) {\n              // `status` should not be persisted as it messes with reconnection\n              if (\n                typeof persistedState === 'object' &&\n                persistedState &&\n                'status' in persistedState\n              )\n                delete persistedState.status\n              // Make sure persisted `chainId` is valid\n              const chainId = validatePersistedChainId(\n                persistedState,\n                currentState.chainId,\n              )\n              return {\n                ...currentState,\n                ...(persistedState as object),\n                chainId,\n              }\n            },\n            skipHydration: ssr,\n            storage: storage as Storage<Record<string, unknown>>,\n            version: currentVersion,\n          })\n        : getInitialState,\n    ),\n  )\n  store.setState(getInitialState())\n\n  function validatePersistedChainId(\n    persistedState: unknown,\n    defaultChainId: number,\n  ) {\n    return persistedState &&\n      typeof persistedState === 'object' &&\n      'chainId' in persistedState &&\n      typeof persistedState.chainId === 'number' &&\n      chains.getState().some((x) => x.id === persistedState.chainId)\n      ? persistedState.chainId\n      : defaultChainId\n  }\n\n  /////////////////////////////////////////////////////////////////////////////////////////////////\n  // Subscribe to changes\n  /////////////////////////////////////////////////////////////////////////////////////////////////\n\n  // Update default chain when connector chain changes\n  if (syncConnectedChain)\n    store.subscribe(\n      ({ connections, current }) =>\n        current ? connections.get(current)?.chainId : undefined,\n      (chainId) => {\n        // If chain is not configured, then don't switch over to it.\n        const isChainConfigured = chains\n          .getState()\n          .some((x) => x.id === chainId)\n        if (!isChainConfigured) return\n\n        return store.setState((x) => ({\n          ...x,\n          chainId: chainId ?? x.chainId,\n        }))\n      },\n    )\n\n  // EIP-6963 subscribe for new wallet providers\n  mipd?.subscribe((providerDetails) => {\n    const connectorIdSet = new Set<string>()\n    const connectorRdnsSet = new Set<string>()\n    for (const connector of connectors.getState()) {\n      connectorIdSet.add(connector.id)\n      if (connector.rdns) {\n        const rdnsValues =\n          typeof connector.rdns === 'string' ? [connector.rdns] : connector.rdns\n        for (const rdns of rdnsValues) {\n          connectorRdnsSet.add(rdns)\n        }\n      }\n    }\n\n    const newConnectors: Connector[] = []\n    for (const providerDetail of providerDetails) {\n      if (connectorRdnsSet.has(providerDetail.info.rdns)) continue\n      const connector = setup(providerDetailToConnector(providerDetail))\n      if (connectorIdSet.has(connector.id)) continue\n      newConnectors.push(connector)\n    }\n\n    if (storage && !store.persist.hasHydrated()) return\n    connectors.setState((x) => [...x, ...newConnectors], true)\n  })\n\n  /////////////////////////////////////////////////////////////////////////////////////////////////\n  // Emitter listeners\n  /////////////////////////////////////////////////////////////////////////////////////////////////\n\n  function change(data: EventData<ConnectorEventMap, 'change'>) {\n    store.setState((x) => {\n      const connection = x.connections.get(data.uid)\n      if (!connection) return x\n      return {\n        ...x,\n        connections: new Map(x.connections).set(data.uid, {\n          accounts:\n            (data.accounts as readonly [Address, ...Address[]]) ??\n            connection.accounts,\n          chainId: data.chainId ?? connection.chainId,\n          connector: connection.connector,\n        }),\n      }\n    })\n  }\n  function connect(data: EventData<ConnectorEventMap, 'connect'>) {\n    // Disable handling if reconnecting/connecting\n    if (\n      store.getState().status === 'connecting' ||\n      store.getState().status === 'reconnecting'\n    )\n      return\n\n    store.setState((x) => {\n      const connector = connectors.getState().find((x) => x.uid === data.uid)\n      if (!connector) return x\n\n      if (connector.emitter.listenerCount('connect'))\n        connector.emitter.off('connect', change)\n      if (!connector.emitter.listenerCount('change'))\n        connector.emitter.on('change', change)\n      if (!connector.emitter.listenerCount('disconnect'))\n        connector.emitter.on('disconnect', disconnect)\n\n      return {\n        ...x,\n        connections: new Map(x.connections).set(data.uid, {\n          accounts: data.accounts as readonly [Address, ...Address[]],\n          chainId: data.chainId,\n          connector: connector,\n        }),\n        current: data.uid,\n        status: 'connected',\n      }\n    })\n  }\n  function disconnect(data: EventData<ConnectorEventMap, 'disconnect'>) {\n    store.setState((x) => {\n      const connection = x.connections.get(data.uid)\n      if (connection) {\n        const connector = connection.connector\n        if (connector.emitter.listenerCount('change'))\n          connection.connector.emitter.off('change', change)\n        if (connector.emitter.listenerCount('disconnect'))\n          connection.connector.emitter.off('disconnect', disconnect)\n        if (!connector.emitter.listenerCount('connect'))\n          connection.connector.emitter.on('connect', connect)\n      }\n\n      x.connections.delete(data.uid)\n\n      if (x.connections.size === 0)\n        return {\n          ...x,\n          connections: new Map(),\n          current: null,\n          status: 'disconnected',\n        }\n\n      const nextConnection = x.connections.values().next().value as Connection\n      return {\n        ...x,\n        connections: new Map(x.connections),\n        current: nextConnection.connector.uid,\n      }\n    })\n  }\n\n  return {\n    get chains() {\n      return chains.getState() as chains\n    },\n    get connectors() {\n      return connectors.getState() as Connector<connectorFns[number]>[]\n    },\n    storage,\n\n    getClient,\n    get state() {\n      return store.getState() as unknown as State<chains>\n    },\n    setState(value) {\n      let newState: State\n      if (typeof value === 'function') newState = value(store.getState() as any)\n      else newState = value\n\n      // Reset state if it got set to something not matching the base state\n      const initialState = getInitialState()\n      if (typeof newState !== 'object') newState = initialState\n      const isCorrupt = Object.keys(initialState).some((x) => !(x in newState))\n      if (isCorrupt) newState = initialState\n\n      store.setState(newState, true)\n    },\n    subscribe(selector, listener, options) {\n      return store.subscribe(\n        selector as unknown as (state: State) => any,\n        listener,\n        options\n          ? ({\n              ...options,\n              fireImmediately: options.emitImmediately,\n              // Workaround cast since Zustand does not support `'exactOptionalPropertyTypes'`\n            } as RemoveUndefined<typeof options>)\n          : undefined,\n      )\n    },\n\n    _internal: {\n      mipd,\n      async revalidate() {\n        // Check connections to see if they are still active\n        const state = store.getState()\n        const connections = state.connections\n        let current = state.current\n        for (const [, connection] of connections) {\n          const connector = connection.connector\n          // check if `connect.isAuthorized` exists\n          // partial connectors in storage do not have it\n          const isAuthorized = connector.isAuthorized\n            ? await connector.isAuthorized()\n            : false\n          if (isAuthorized) continue\n          // Remove stale connection\n          connections.delete(connector.uid)\n          if (current === connector.uid) current = null\n        }\n        // set connections\n        store.setState((x) => ({ ...x, connections, current }))\n      },\n      store,\n      ssr: Boolean(ssr),\n      syncConnectedChain,\n      transports: rest.transports as transports,\n      chains: {\n        setState(value) {\n          const nextChains = (\n            typeof value === 'function' ? value(chains.getState()) : value\n          ) as chains\n          if (nextChains.length === 0) return\n          return chains.setState(nextChains, true)\n        },\n        subscribe(listener) {\n          return chains.subscribe(listener)\n        },\n      },\n      connectors: {\n        providerDetailToConnector,\n        setup: setup as <connectorFn extends CreateConnectorFn>(\n          connectorFn: connectorFn,\n        ) => Connector<connectorFn>,\n        setState(value) {\n          return connectors.setState(\n            typeof value === 'function' ? value(connectors.getState()) : value,\n            true,\n          )\n        },\n        subscribe(listener) {\n          return connectors.subscribe(listener)\n        },\n      },\n      events: { change, connect, disconnect },\n    },\n  }\n}\n\n/////////////////////////////////////////////////////////////////////////////////////////////////\n// Types\n/////////////////////////////////////////////////////////////////////////////////////////////////\n\nexport type CreateConfigParameters<\n  chains extends readonly [Chain, ...Chain[]] = readonly [Chain, ...Chain[]],\n  transports extends Record<chains[number]['id'], Transport> = Record<\n    chains[number]['id'],\n    Transport\n  >,\n  connectorFns extends\n    readonly CreateConnectorFn[] = readonly CreateConnectorFn[],\n> = Compute<\n  {\n    chains: chains\n    connectors?: connectorFns | undefined\n    multiInjectedProviderDiscovery?: boolean | undefined\n    storage?: Storage | null | undefined\n    ssr?: boolean | undefined\n    syncConnectedChain?: boolean | undefined\n  } & OneOf<\n    | ({ transports: transports } & {\n        [key in keyof ClientConfig]?:\n          | ClientConfig[key]\n          | { [_ in chains[number]['id']]?: ClientConfig[key] | undefined }\n          | undefined\n      })\n    | {\n        client(parameters: {\n          chain: chains[number]\n        }): Client<transports[chains[number]['id']], chains[number]>\n      }\n  >\n>\n\nexport type Config<\n  chains extends readonly [Chain, ...Chain[]] = readonly [Chain, ...Chain[]],\n  transports extends Record<chains[number]['id'], Transport> = Record<\n    chains[number]['id'],\n    Transport\n  >,\n  connectorFns extends\n    readonly CreateConnectorFn[] = readonly CreateConnectorFn[],\n> = {\n  readonly chains: chains\n  readonly connectors: readonly Connector<connectorFns[number]>[]\n  readonly storage: Storage | null\n\n  readonly state: State<chains>\n  setState<tchains extends readonly [Chain, ...Chain[]] = chains>(\n    value: State<tchains> | ((state: State<tchains>) => State<tchains>),\n  ): void\n  subscribe<state>(\n    selector: (state: State<chains>) => state,\n    listener: (state: state, previousState: state) => void,\n    options?:\n      | {\n          emitImmediately?: boolean | undefined\n          equalityFn?: ((a: state, b: state) => boolean) | undefined\n        }\n      | undefined,\n  ): () => void\n\n  getClient<chainId extends chains[number]['id']>(parameters?: {\n    chainId?: chainId | chains[number]['id'] | undefined\n  }): Client<transports[chainId], Extract<chains[number], { id: chainId }>>\n\n  /**\n   * Not part of versioned API, proceed with caution.\n   * @internal\n   */\n  _internal: Internal<chains, transports>\n}\n\ntype Internal<\n  chains extends readonly [Chain, ...Chain[]] = readonly [Chain, ...Chain[]],\n  transports extends Record<chains[number]['id'], Transport> = Record<\n    chains[number]['id'],\n    Transport\n  >,\n> = {\n  readonly mipd: MipdStore | undefined\n  revalidate: () => Promise<void>\n  readonly store: Mutate<StoreApi<any>, [['zustand/persist', any]]>\n  readonly ssr: boolean\n  readonly syncConnectedChain: boolean\n  readonly transports: transports\n\n  chains: {\n    setState(\n      value:\n        | readonly [Chain, ...Chain[]]\n        | ((\n            state: readonly [Chain, ...Chain[]],\n          ) => readonly [Chain, ...Chain[]]),\n    ): void\n    subscribe(\n      listener: (\n        state: readonly [Chain, ...Chain[]],\n        prevState: readonly [Chain, ...Chain[]],\n      ) => void,\n    ): () => void\n  }\n  connectors: {\n    providerDetailToConnector(\n      providerDetail: EIP6963ProviderDetail,\n    ): CreateConnectorFn\n    setup<connectorFn extends CreateConnectorFn>(\n      connectorFn: connectorFn,\n    ): Connector<connectorFn>\n    setState(value: Connector[] | ((state: Connector[]) => Connector[])): void\n    subscribe(\n      listener: (state: Connector[], prevState: Connector[]) => void,\n    ): () => void\n  }\n  events: {\n    change(data: EventData<ConnectorEventMap, 'change'>): void\n    connect(data: EventData<ConnectorEventMap, 'connect'>): void\n    disconnect(data: EventData<ConnectorEventMap, 'disconnect'>): void\n  }\n}\n\nexport type State<\n  chains extends readonly [Chain, ...Chain[]] = readonly [Chain, ...Chain[]],\n> = {\n  chainId: chains[number]['id']\n  connections: Map<string, Connection>\n  current: string | null\n  status: 'connected' | 'connecting' | 'disconnected' | 'reconnecting'\n}\n\nexport type PartializedState = Compute<\n  ExactPartial<Pick<State, 'chainId' | 'connections' | 'current' | 'status'>>\n>\n\nexport type Connection = {\n  accounts: readonly [Address, ...Address[]]\n  chainId: number\n  connector: Connector\n}\n\nexport type Connector<\n  createConnectorFn extends CreateConnectorFn = CreateConnectorFn,\n> = ReturnType<createConnectorFn> & {\n  emitter: Emitter<ConnectorEventMap>\n  uid: string\n}\n\nexport type Transport<\n  type extends string = string,\n  rpcAttributes = Record<string, any>,\n  eip1193RequestFn extends EIP1193RequestFn = EIP1193RequestFn,\n> = (\n  params: Parameters<\n    viem_Transport<type, rpcAttributes, eip1193RequestFn>\n  >[0] & {\n    connectors?: StoreApi<Connector[]> | undefined\n  },\n) => ReturnType<viem_Transport<type, rpcAttributes, eip1193RequestFn>>\n\ntype ClientConfig = LooseOmit<\n  viem_ClientConfig,\n  'account' | 'chain' | 'key' | 'name' | 'transport' | 'type'\n>\n","import {\n  type AddEthereumChainParameter,\n  type Address,\n  type EIP1193Provider,\n  getAddress,\n  numberToHex,\n  type ProviderConnectInfo,\n  type ProviderRpcError,\n  ResourceUnavailableRpcError,\n  type RpcError,\n  SwitchChainError,\n  UserRejectedRequestError,\n  withRetry,\n  withTimeout,\n} from 'viem'\n\nimport type { Connector } from '../createConfig.js'\nimport { ChainNotConfiguredError } from '../errors/config.js'\nimport { ProviderNotFoundError } from '../errors/connector.js'\nimport type { Compute } from '../types/utils.js'\nimport { createConnector } from './createConnector.js'\n\nexport type InjectedParameters = {\n  /**\n   * Some injected providers do not support programmatic disconnect.\n   * This flag simulates the disconnect behavior by keeping track of connection status in storage.\n   * @default true\n   */\n  shimDisconnect?: boolean | undefined\n  /**\n   * [EIP-1193](https://eips.ethereum.org/EIPS/eip-1193) Ethereum Provider to target\n   */\n  target?: TargetId | Target | (() => Target | undefined) | undefined\n  unstable_shimAsyncInject?: boolean | number | undefined\n}\n\ninjected.type = 'injected' as const\nexport function injected(parameters: InjectedParameters = {}) {\n  const { shimDisconnect = true, unstable_shimAsyncInject } = parameters\n\n  function getTarget(): Compute<Target & { id: string }> {\n    const target = parameters.target\n    if (typeof target === 'function') {\n      const result = target()\n      if (result) return result\n    }\n\n    if (typeof target === 'object') return target\n\n    if (typeof target === 'string')\n      return {\n        ...(targetMap[target as keyof typeof targetMap] ?? {\n          id: target,\n          name: `${target[0]!.toUpperCase()}${target.slice(1)}`,\n          provider: `is${target[0]!.toUpperCase()}${target.slice(1)}`,\n        }),\n      }\n\n    return {\n      id: 'injected',\n      name: 'Injected',\n      provider(window) {\n        return window?.ethereum\n      },\n    }\n  }\n\n  type Provider = WalletProvider | undefined\n  type Properties = {\n    onConnect(connectInfo: ProviderConnectInfo): void\n  }\n  type StorageItem = {\n    [_ in 'injected.connected' | `${string}.disconnected`]: true\n  }\n\n  let accountsChanged: Connector['onAccountsChanged'] | undefined\n  let chainChanged: Connector['onChainChanged'] | undefined\n  let connect: Connector['onConnect'] | undefined\n  let disconnect: Connector['onDisconnect'] | undefined\n\n  return createConnector<Provider, Properties, StorageItem>((config) => ({\n    get icon() {\n      return getTarget().icon\n    },\n    get id() {\n      return getTarget().id\n    },\n    get name() {\n      return getTarget().name\n    },\n    /** @deprecated */\n    get supportsSimulation() {\n      return true\n    },\n    type: injected.type,\n    async setup() {\n      const provider = await this.getProvider()\n      // Only start listening for events if `target` is set, otherwise `injected()` will also receive events\n      if (provider?.on && parameters.target) {\n        if (!connect) {\n          connect = this.onConnect.bind(this)\n          provider.on('connect', connect)\n        }\n\n        // We shouldn't need to listen for `'accountsChanged'` here since the `'connect'` event should suffice (and wallet shouldn't be connected yet).\n        // Some wallets, like MetaMask, do not implement the `'connect'` event and overload `'accountsChanged'` instead.\n        if (!accountsChanged) {\n          accountsChanged = this.onAccountsChanged.bind(this)\n          provider.on('accountsChanged', accountsChanged)\n        }\n      }\n    },\n    async connect({ chainId, isReconnecting, withCapabilities } = {}) {\n      const provider = await this.getProvider()\n      if (!provider) throw new ProviderNotFoundError()\n\n      let accounts: readonly Address[] = []\n      if (isReconnecting) accounts = await this.getAccounts().catch(() => [])\n      else if (shimDisconnect) {\n        // Attempt to show another prompt for selecting account if `shimDisconnect` flag is enabled\n        try {\n          const permissions = await provider.request({\n            method: 'wallet_requestPermissions',\n            params: [{ eth_accounts: {} }],\n          })\n          accounts = (permissions[0]?.caveats?.[0]?.value as string[])?.map(\n            (x) => getAddress(x),\n          )\n          // `'wallet_requestPermissions'` can return a different order of accounts than `'eth_accounts'`\n          // switch to `'eth_accounts'` ordering if more than one account is connected\n          // https://github.com/wevm/wagmi/issues/4140\n          if (accounts.length > 0) {\n            const sortedAccounts = await this.getAccounts()\n            accounts = sortedAccounts\n          }\n        } catch (err) {\n          const error = err as RpcError\n          // Not all injected providers support `wallet_requestPermissions` (e.g. MetaMask iOS).\n          // Only bubble up error if user rejects request\n          if (error.code === UserRejectedRequestError.code)\n            throw new UserRejectedRequestError(error)\n          // Or prompt is already open\n          if (error.code === ResourceUnavailableRpcError.code) throw error\n        }\n      }\n\n      try {\n        if (!accounts?.length && !isReconnecting) {\n          const requestedAccounts = await provider.request({\n            method: 'eth_requestAccounts',\n          })\n          accounts = requestedAccounts.map((x) => getAddress(x))\n        }\n\n        // Manage EIP-1193 event listeners\n        // https://eips.ethereum.org/EIPS/eip-1193#events\n        if (connect) {\n          provider.removeListener('connect', connect)\n          connect = undefined\n        }\n        if (!accountsChanged) {\n          accountsChanged = this.onAccountsChanged.bind(this)\n          provider.on('accountsChanged', accountsChanged)\n        }\n        if (!chainChanged) {\n          chainChanged = this.onChainChanged.bind(this)\n          provider.on('chainChanged', chainChanged)\n        }\n        if (!disconnect) {\n          disconnect = this.onDisconnect.bind(this)\n          provider.on('disconnect', disconnect)\n        }\n\n        // Switch to chain if provided\n        let currentChainId = await this.getChainId()\n        if (chainId && currentChainId !== chainId) {\n          const chain = await this.switchChain!({ chainId }).catch((error) => {\n            if (error.code === UserRejectedRequestError.code) throw error\n            return { id: currentChainId }\n          })\n          currentChainId = chain?.id ?? currentChainId\n        }\n\n        // Remove disconnected shim if it exists\n        if (shimDisconnect)\n          await config.storage?.removeItem(`${this.id}.disconnected`)\n\n        // Add connected shim if no target exists\n        if (!parameters.target)\n          await config.storage?.setItem('injected.connected', true)\n\n        return {\n          accounts: (withCapabilities\n            ? accounts.map((address) => ({ address, capabilities: {} }))\n            : accounts) as never,\n          chainId: currentChainId,\n        }\n      } catch (err) {\n        const error = err as RpcError\n        if (error.code === UserRejectedRequestError.code)\n          throw new UserRejectedRequestError(error)\n        if (error.code === ResourceUnavailableRpcError.code)\n          throw new ResourceUnavailableRpcError(error)\n        throw error\n      }\n    },\n    async disconnect() {\n      const provider = await this.getProvider()\n      if (!provider) throw new ProviderNotFoundError()\n\n      // Manage EIP-1193 event listeners\n      if (chainChanged) {\n        provider.removeListener('chainChanged', chainChanged)\n        chainChanged = undefined\n      }\n      if (disconnect) {\n        provider.removeListener('disconnect', disconnect)\n        disconnect = undefined\n      }\n      if (!connect) {\n        connect = this.onConnect.bind(this)\n        provider.on('connect', connect)\n      }\n\n      // Experimental support for MetaMask disconnect\n      // https://github.com/MetaMask/metamask-improvement-proposals/blob/main/MIPs/mip-2.md\n      try {\n        // Adding timeout as not all wallets support this method and can hang\n        // https://github.com/wevm/wagmi/issues/4064\n        await withTimeout(\n          () =>\n            // TODO: Remove explicit type for viem@3\n            provider.request<{\n              Method: 'wallet_revokePermissions'\n              Parameters: [permissions: { eth_accounts: Record<string, any> }]\n              ReturnType: null\n            }>({\n              // `'wallet_revokePermissions'` added in `viem@2.10.3`\n              method: 'wallet_revokePermissions',\n              params: [{ eth_accounts: {} }],\n            }),\n          { timeout: 100 },\n        )\n      } catch {}\n\n      // Add shim signalling connector is disconnected\n      if (shimDisconnect) {\n        await config.storage?.setItem(`${this.id}.disconnected`, true)\n      }\n\n      if (!parameters.target)\n        await config.storage?.removeItem('injected.connected')\n    },\n    async getAccounts() {\n      const provider = await this.getProvider()\n      if (!provider) throw new ProviderNotFoundError()\n      const accounts = await provider.request({ method: 'eth_accounts' })\n      return accounts.map((x) => getAddress(x))\n    },\n    async getChainId() {\n      const provider = await this.getProvider()\n      if (!provider) throw new ProviderNotFoundError()\n      const hexChainId = await provider.request({ method: 'eth_chainId' })\n      return Number(hexChainId)\n    },\n    async getProvider() {\n      if (typeof window === 'undefined') return undefined\n\n      let provider: Provider\n      const target = getTarget()\n      if (typeof target.provider === 'function')\n        provider = target.provider(window as Window | undefined)\n      else if (typeof target.provider === 'string')\n        provider = findProvider(window, target.provider)\n      else provider = target.provider\n\n      // Some wallets do not conform to EIP-1193 (e.g. Trust Wallet)\n      // https://github.com/wevm/wagmi/issues/3526#issuecomment-1912683002\n      if (provider && !provider.removeListener) {\n        // Try using `off` handler if it exists, otherwise noop\n        if ('off' in provider && typeof provider.off === 'function')\n          provider.removeListener =\n            provider.off as typeof provider.removeListener\n        else provider.removeListener = () => {}\n      }\n\n      return provider\n    },\n    async isAuthorized() {\n      try {\n        const isDisconnected =\n          shimDisconnect &&\n          // If shim exists in storage, connector is disconnected\n          (await config.storage?.getItem(`${this.id}.disconnected`))\n        if (isDisconnected) return false\n\n        // Don't allow injected connector to connect if no target is set and it hasn't already connected\n        // (e.g. flag in storage is not set). This prevents a targetless injected connector from connecting\n        // automatically whenever there is a targeted connector configured.\n        if (!parameters.target) {\n          const connected = await config.storage?.getItem('injected.connected')\n          if (!connected) return false\n        }\n\n        const provider = await this.getProvider()\n        if (!provider) {\n          if (\n            unstable_shimAsyncInject !== undefined &&\n            unstable_shimAsyncInject !== false\n          ) {\n            // If no provider is found, check for async injection\n            // https://github.com/wevm/references/issues/167\n            // https://github.com/MetaMask/detect-provider\n            const handleEthereum = async () => {\n              if (typeof window !== 'undefined')\n                window.removeEventListener(\n                  'ethereum#initialized',\n                  handleEthereum,\n                )\n              const provider = await this.getProvider()\n              return !!provider\n            }\n            const timeout =\n              typeof unstable_shimAsyncInject === 'number'\n                ? unstable_shimAsyncInject\n                : 1_000\n            const res = await Promise.race([\n              ...(typeof window !== 'undefined'\n                ? [\n                    new Promise<boolean>((resolve) =>\n                      window.addEventListener(\n                        'ethereum#initialized',\n                        () => resolve(handleEthereum()),\n                        { once: true },\n                      ),\n                    ),\n                  ]\n                : []),\n              new Promise<boolean>((resolve) =>\n                setTimeout(() => resolve(handleEthereum()), timeout),\n              ),\n            ])\n            if (res) return true\n          }\n\n          throw new ProviderNotFoundError()\n        }\n\n        // Use retry strategy as some injected wallets (e.g. MetaMask) fail to\n        // immediately resolve JSON-RPC requests on page load.\n        const accounts = await withRetry(() => this.getAccounts())\n        return !!accounts.length\n      } catch {\n        return false\n      }\n    },\n    async switchChain({ addEthereumChainParameter, chainId }) {\n      const provider = await this.getProvider()\n      if (!provider) throw new ProviderNotFoundError()\n\n      const chain = config.chains.find((x) => x.id === chainId)\n      if (!chain) throw new SwitchChainError(new ChainNotConfiguredError())\n\n      const promise = new Promise<void>((resolve) => {\n        const listener = ((data) => {\n          if ('chainId' in data && data.chainId === chainId) {\n            config.emitter.off('change', listener)\n            resolve()\n          }\n        }) satisfies Parameters<typeof config.emitter.on>[1]\n        config.emitter.on('change', listener)\n      })\n\n      try {\n        await Promise.all([\n          provider\n            .request({\n              method: 'wallet_switchEthereumChain',\n              params: [{ chainId: numberToHex(chainId) }],\n            })\n            // During `'wallet_switchEthereumChain'`, MetaMask makes a `'net_version'` RPC call to the target chain.\n            // If this request fails, MetaMask does not emit the `'chainChanged'` event, but will still switch the chain.\n            // To counter this behavior, we request and emit the current chain ID to confirm the chain switch either via\n            // this callback or an externally emitted `'chainChanged'` event.\n            // https://github.com/MetaMask/metamask-extension/issues/24247\n            .then(async () => {\n              const currentChainId = await this.getChainId()\n              if (currentChainId === chainId)\n                config.emitter.emit('change', { chainId })\n            }),\n          promise,\n        ])\n        return chain\n      } catch (err) {\n        const error = err as RpcError\n\n        // Indicates chain is not added to provider\n        if (\n          error.code === 4902 ||\n          // Unwrapping for MetaMask Mobile\n          // https://github.com/MetaMask/metamask-mobile/issues/2944#issuecomment-976988719\n          (error as ProviderRpcError<{ originalError?: { code: number } }>)\n            ?.data?.originalError?.code === 4902\n        ) {\n          try {\n            const { default: blockExplorer, ...blockExplorers } =\n              chain.blockExplorers ?? {}\n            let blockExplorerUrls: string[] | undefined\n            if (addEthereumChainParameter?.blockExplorerUrls)\n              blockExplorerUrls = addEthereumChainParameter.blockExplorerUrls\n            else if (blockExplorer)\n              blockExplorerUrls = [\n                blockExplorer.url,\n                ...Object.values(blockExplorers).map((x) => x.url),\n              ]\n\n            let rpcUrls: readonly string[]\n            if (addEthereumChainParameter?.rpcUrls?.length)\n              rpcUrls = addEthereumChainParameter.rpcUrls\n            else rpcUrls = [chain.rpcUrls.default?.http[0] ?? '']\n\n            const addEthereumChain = {\n              blockExplorerUrls,\n              chainId: numberToHex(chainId),\n              chainName: addEthereumChainParameter?.chainName ?? chain.name,\n              iconUrls: addEthereumChainParameter?.iconUrls,\n              nativeCurrency:\n                addEthereumChainParameter?.nativeCurrency ??\n                chain.nativeCurrency,\n              rpcUrls,\n            } satisfies AddEthereumChainParameter\n\n            await Promise.all([\n              provider\n                .request({\n                  method: 'wallet_addEthereumChain',\n                  params: [addEthereumChain],\n                })\n                .then(async () => {\n                  const currentChainId = await this.getChainId()\n                  if (currentChainId === chainId)\n                    config.emitter.emit('change', { chainId })\n                  else\n                    throw new UserRejectedRequestError(\n                      new Error('User rejected switch after adding network.'),\n                    )\n                }),\n              promise,\n            ])\n\n            return chain\n          } catch (error) {\n            throw new UserRejectedRequestError(error as Error)\n          }\n        }\n\n        if (error.code === UserRejectedRequestError.code)\n          throw new UserRejectedRequestError(error)\n        throw new SwitchChainError(error)\n      }\n    },\n    async onAccountsChanged(accounts) {\n      // Disconnect if there are no accounts\n      if (accounts.length === 0) this.onDisconnect()\n      // Connect if emitter is listening for connect event (e.g. is disconnected and connects through wallet interface)\n      else if (config.emitter.listenerCount('connect')) {\n        const chainId = (await this.getChainId()).toString()\n        this.onConnect({ chainId })\n        // Remove disconnected shim if it exists\n        if (shimDisconnect)\n          await config.storage?.removeItem(`${this.id}.disconnected`)\n      }\n      // Regular change event\n      else\n        config.emitter.emit('change', {\n          accounts: accounts.map((x) => getAddress(x)),\n        })\n    },\n    onChainChanged(chain) {\n      const chainId = Number(chain)\n      config.emitter.emit('change', { chainId })\n    },\n    async onConnect(connectInfo) {\n      const accounts = await this.getAccounts()\n      if (accounts.length === 0) return\n\n      const chainId = Number(connectInfo.chainId)\n      config.emitter.emit('connect', { accounts, chainId })\n\n      // Manage EIP-1193 event listeners\n      const provider = await this.getProvider()\n      if (provider) {\n        if (connect) {\n          provider.removeListener('connect', connect)\n          connect = undefined\n        }\n        if (!accountsChanged) {\n          accountsChanged = this.onAccountsChanged.bind(this)\n          provider.on('accountsChanged', accountsChanged)\n        }\n        if (!chainChanged) {\n          chainChanged = this.onChainChanged.bind(this)\n          provider.on('chainChanged', chainChanged)\n        }\n        if (!disconnect) {\n          disconnect = this.onDisconnect.bind(this)\n          provider.on('disconnect', disconnect)\n        }\n      }\n    },\n    async onDisconnect(error) {\n      const provider = await this.getProvider()\n\n      // If MetaMask emits a `code: 1013` error, wait for reconnection before disconnecting\n      // https://github.com/MetaMask/providers/pull/120\n      if (error && (error as RpcError<1013>).code === 1013) {\n        if (provider && !!(await this.getAccounts()).length) return\n      }\n\n      // No need to remove `${this.id}.disconnected` from storage because `onDisconnect` is typically\n      // only called when the wallet is disconnected through the wallet's interface, meaning the wallet\n      // actually disconnected and we don't need to simulate it.\n      config.emitter.emit('disconnect')\n\n      // Manage EIP-1193 event listeners\n      if (provider) {\n        if (chainChanged) {\n          provider.removeListener('chainChanged', chainChanged)\n          chainChanged = undefined\n        }\n        if (disconnect) {\n          provider.removeListener('disconnect', disconnect)\n          disconnect = undefined\n        }\n        if (!connect) {\n          connect = this.onConnect.bind(this)\n          provider.on('connect', connect)\n        }\n      }\n    },\n  }))\n}\n\nconst targetMap = {\n  coinbaseWallet: {\n    id: 'coinbaseWallet',\n    name: 'Coinbase Wallet',\n    provider(window) {\n      if (window?.coinbaseWalletExtension) return window.coinbaseWalletExtension\n      return findProvider(window, 'isCoinbaseWallet')\n    },\n  },\n  metaMask: {\n    id: 'metaMask',\n    name: 'MetaMask',\n    provider(window) {\n      return findProvider(window, (provider) => {\n        if (!provider.isMetaMask) return false\n        // Brave tries to make itself look like MetaMask\n        // Could also try RPC `web3_clientVersion` if following is unreliable\n        if (provider.isBraveWallet && !provider._events && !provider._state)\n          return false\n        // Other wallets that try to look like MetaMask\n        const flags = [\n          'isApexWallet',\n          'isAvalanche',\n          'isBitKeep',\n          'isBlockWallet',\n          'isKuCoinWallet',\n          'isMathWallet',\n          'isOkxWallet',\n          'isOKExWallet',\n          'isOneInchIOSWallet',\n          'isOneInchAndroidWallet',\n          'isOpera',\n          'isPhantom',\n          'isPortal',\n          'isRabby',\n          'isTokenPocket',\n          'isTokenary',\n          'isUniswapWallet',\n          'isZerion',\n        ] satisfies WalletProviderFlags[]\n        for (const flag of flags) if (provider[flag]) return false\n        return true\n      })\n    },\n  },\n  phantom: {\n    id: 'phantom',\n    name: 'Phantom',\n    provider(window) {\n      if (window?.phantom?.ethereum) return window.phantom?.ethereum\n      return findProvider(window, 'isPhantom')\n    },\n  },\n} as const satisfies TargetMap\n\ntype TargetMap = { [_ in TargetId]?: Target | undefined }\n\ntype Target = {\n  icon?: string | undefined\n  id: string\n  name: string\n  provider:\n    | WalletProviderFlags\n    | WalletProvider\n    | ((window?: Window | undefined) => WalletProvider | undefined)\n}\n\n/** @deprecated */\ntype TargetId = Compute<WalletProviderFlags> extends `is${infer name}`\n  ? name extends `${infer char}${infer rest}`\n    ? `${Lowercase<char>}${rest}`\n    : never\n  : never\n\n/**\n * @deprecated As of 2024/10/16, we are no longer accepting new provider flags as EIP-6963 should be used instead.\n */\ntype WalletProviderFlags =\n  | 'isApexWallet'\n  | 'isAvalanche'\n  | 'isBackpack'\n  | 'isBifrost'\n  | 'isBitKeep'\n  | 'isBitski'\n  | 'isBlockWallet'\n  | 'isBraveWallet'\n  | 'isCoinbaseWallet'\n  | 'isDawn'\n  | 'isEnkrypt'\n  | 'isExodus'\n  | 'isFrame'\n  | 'isFrontier'\n  | 'isGamestop'\n  | 'isHyperPay'\n  | 'isImToken'\n  | 'isKuCoinWallet'\n  | 'isMathWallet'\n  | 'isMetaMask'\n  | 'isOkxWallet'\n  | 'isOKExWallet'\n  | 'isOneInchAndroidWallet'\n  | 'isOneInchIOSWallet'\n  | 'isOpera'\n  | 'isPhantom'\n  | 'isPortal'\n  | 'isRabby'\n  | 'isRainbow'\n  | 'isStatus'\n  | 'isTally'\n  | 'isTokenPocket'\n  | 'isTokenary'\n  | 'isTrust'\n  | 'isTrustWallet'\n  | 'isUniswapWallet'\n  | 'isXDEFI'\n  | 'isZerion'\n\ntype WalletProvider = Compute<\n  EIP1193Provider & {\n    [key in WalletProviderFlags]?: true | undefined\n  } & {\n    providers?: WalletProvider[] | undefined\n    /** Only exists in MetaMask as of 2022/04/03 */\n    _events?: { connect?: (() => void) | undefined } | undefined\n    /** Only exists in MetaMask as of 2022/04/03 */\n    _state?:\n      | {\n          accounts?: string[]\n          initialized?: boolean\n          isConnected?: boolean\n          isPermanentlyDisconnected?: boolean\n          isUnlocked?: boolean\n        }\n      | undefined\n  }\n>\n\ntype Window = {\n  coinbaseWalletExtension?: WalletProvider | undefined\n  ethereum?: WalletProvider | undefined\n  phantom?: { ethereum: WalletProvider } | undefined\n}\n\nfunction findProvider(\n  window: globalThis.Window | Window | undefined,\n  select?: WalletProviderFlags | ((provider: WalletProvider) => boolean),\n) {\n  function isProvider(provider: WalletProvider) {\n    if (typeof select === 'function') return select(provider)\n    if (typeof select === 'string') return provider[select]\n    return true\n  }\n\n  const ethereum = (window as Window).ethereum\n  if (ethereum?.providers)\n    return ethereum.providers.find((provider) => isProvider(provider))\n  if (ethereum && isProvider(ethereum)) return ethereum\n  return undefined\n}\n","import type {\n  createCoinbaseWalletSDK,\n  Preference,\n  ProviderInterface,\n} from '@coinbase/wallet-sdk'\nimport {\n  ChainNotConfiguredError,\n  type Connector,\n  createConnector,\n} from '@wagmi/core'\nimport type { Compute, Mutable, Omit } from '@wagmi/core/internal'\nimport type {\n  CoinbaseWalletProvider as CBW_Provider,\n  CoinbaseWalletSDK as CBW_SDK,\n} from 'cbw-sdk'\nimport {\n  type AddEthereumChainParameter,\n  type Address,\n  getAddress,\n  type Hex,\n  numberToHex,\n  type ProviderRpcError,\n  SwitchChainError,\n  UserRejectedRequestError,\n} from 'viem'\n\ntype Version = '3' | '4'\n\nexport type CoinbaseWalletParameters<version extends Version = '3'> =\n  version extends '4'\n    ? Compute<\n        {\n          headlessMode?: false | undefined\n          /** Coinbase Wallet SDK version */\n          version?: version | '3' | undefined\n        } & Version4Parameters\n      >\n    : Compute<\n        {\n          /**\n           * @deprecated `headlessMode` will be removed in the next major version. Upgrade to `version: '4'`.\n           */\n          headlessMode?: true | undefined\n          /**\n           * Coinbase Wallet SDK version\n           * @deprecated Version 3 will be removed in the next major version. Upgrade to `version: '4'`.\n           * @default '4'\n           */\n          version?: version | '4' | undefined\n        } & Version3Parameters\n      >\n\ncoinbaseWallet.type = 'coinbaseWallet' as const\nexport function coinbaseWallet<version extends Version>(\n  parameters: CoinbaseWalletParameters<version> = {} as any,\n): version extends '4'\n  ? ReturnType<typeof version4>\n  : ReturnType<typeof version3> {\n  if (parameters.version === '3' || parameters.headlessMode)\n    return version3(parameters as Version3Parameters) as any\n  return version4(parameters as Version4Parameters) as any\n}\n\ntype Version4Parameters = Mutable<\n  Omit<\n    Parameters<typeof createCoinbaseWalletSDK>[0],\n    | 'appChainIds' // set via wagmi config\n    | 'preference'\n  > & {\n    // TODO(v3): Remove `Preference['options']`\n    /**\n     * Preference for the type of wallet to display.\n     * @default 'all'\n     */\n    preference?: Preference['options'] | Compute<Preference> | undefined\n  }\n>\n\nfunction version4(parameters: Version4Parameters) {\n  type Provider = ProviderInterface & {\n    // for backwards compatibility\n    close?(): void\n  }\n  type Properties = {\n    // TODO(v3): Make `withCapabilities: true` default behavior\n    connect<withCapabilities extends boolean = false>(parameters?: {\n      chainId?: number | undefined\n      instantOnboarding?: boolean | undefined\n      isReconnecting?: boolean | undefined\n      withCapabilities?: withCapabilities | boolean | undefined\n    }): Promise<{\n      accounts: withCapabilities extends true\n        ? readonly { address: Address }[]\n        : readonly Address[]\n      chainId: number\n    }>\n  }\n\n  let walletProvider: Provider | undefined\n\n  let accountsChanged: Connector['onAccountsChanged'] | undefined\n  let chainChanged: Connector['onChainChanged'] | undefined\n  let disconnect: Connector['onDisconnect'] | undefined\n\n  return createConnector<Provider, Properties>((config) => ({\n    id: 'coinbaseWalletSDK',\n    name: 'Coinbase Wallet',\n    rdns: 'com.coinbase.wallet',\n    type: coinbaseWallet.type,\n    async connect({ chainId, withCapabilities, ...rest } = {}) {\n      try {\n        const provider = await this.getProvider()\n        const accounts = (\n          (await provider.request({\n            method: 'eth_requestAccounts',\n            params:\n              'instantOnboarding' in rest && rest.instantOnboarding\n                ? [{ onboarding: 'instant' }]\n                : [],\n          })) as string[]\n        ).map((x) => getAddress(x))\n\n        if (!accountsChanged) {\n          accountsChanged = this.onAccountsChanged.bind(this)\n          provider.on('accountsChanged', accountsChanged)\n        }\n        if (!chainChanged) {\n          chainChanged = this.onChainChanged.bind(this)\n          provider.on('chainChanged', chainChanged)\n        }\n        if (!disconnect) {\n          disconnect = this.onDisconnect.bind(this)\n          provider.on('disconnect', disconnect)\n        }\n\n        // Switch to chain if provided\n        let currentChainId = await this.getChainId()\n        if (chainId && currentChainId !== chainId) {\n          const chain = await this.switchChain!({ chainId }).catch((error) => {\n            if (error.code === UserRejectedRequestError.code) throw error\n            return { id: currentChainId }\n          })\n          currentChainId = chain?.id ?? currentChainId\n        }\n\n        return {\n          accounts: (withCapabilities\n            ? accounts.map((address) => ({ address, capabilities: {} }))\n            : accounts) as never,\n          chainId: currentChainId,\n        }\n      } catch (error) {\n        if (\n          /(user closed modal|accounts received is empty|user denied account|request rejected)/i.test(\n            (error as Error).message,\n          )\n        )\n          throw new UserRejectedRequestError(error as Error)\n        throw error\n      }\n    },\n    async disconnect() {\n      const provider = await this.getProvider()\n\n      if (accountsChanged) {\n        provider.removeListener('accountsChanged', accountsChanged)\n        accountsChanged = undefined\n      }\n      if (chainChanged) {\n        provider.removeListener('chainChanged', chainChanged)\n        chainChanged = undefined\n      }\n      if (disconnect) {\n        provider.removeListener('disconnect', disconnect)\n        disconnect = undefined\n      }\n\n      provider.disconnect()\n      provider.close?.()\n    },\n    async getAccounts() {\n      const provider = await this.getProvider()\n      return (\n        (await provider.request({\n          method: 'eth_accounts',\n        })) as string[]\n      ).map((x) => getAddress(x))\n    },\n    async getChainId() {\n      const provider = await this.getProvider()\n      const chainId = (await provider.request({\n        method: 'eth_chainId',\n      })) as Hex\n      return Number(chainId)\n    },\n    async getProvider() {\n      if (!walletProvider) {\n        const preference = (() => {\n          if (typeof parameters.preference === 'string')\n            return { options: parameters.preference }\n          return {\n            ...parameters.preference,\n            options: parameters.preference?.options ?? 'all',\n          }\n        })()\n\n        const { createCoinbaseWalletSDK } = await import('@coinbase/wallet-sdk')\n        const sdk = createCoinbaseWalletSDK({\n          ...parameters,\n          appChainIds: config.chains.map((x) => x.id),\n          preference,\n        })\n\n        walletProvider = sdk.getProvider()\n      }\n\n      return walletProvider\n    },\n    async isAuthorized() {\n      try {\n        const accounts = await this.getAccounts()\n        return !!accounts.length\n      } catch {\n        return false\n      }\n    },\n    async switchChain({ addEthereumChainParameter, chainId }) {\n      const chain = config.chains.find((chain) => chain.id === chainId)\n      if (!chain) throw new SwitchChainError(new ChainNotConfiguredError())\n\n      const provider = await this.getProvider()\n\n      try {\n        await provider.request({\n          method: 'wallet_switchEthereumChain',\n          params: [{ chainId: numberToHex(chain.id) }],\n        })\n        return chain\n      } catch (error) {\n        // Indicates chain is not added to provider\n        if ((error as ProviderRpcError).code === 4902) {\n          try {\n            let blockExplorerUrls: string[] | undefined\n            if (addEthereumChainParameter?.blockExplorerUrls)\n              blockExplorerUrls = addEthereumChainParameter.blockExplorerUrls\n            else\n              blockExplorerUrls = chain.blockExplorers?.default.url\n                ? [chain.blockExplorers?.default.url]\n                : []\n\n            let rpcUrls: readonly string[]\n            if (addEthereumChainParameter?.rpcUrls?.length)\n              rpcUrls = addEthereumChainParameter.rpcUrls\n            else rpcUrls = [chain.rpcUrls.default?.http[0] ?? '']\n\n            const addEthereumChain = {\n              blockExplorerUrls,\n              chainId: numberToHex(chainId),\n              chainName: addEthereumChainParameter?.chainName ?? chain.name,\n              iconUrls: addEthereumChainParameter?.iconUrls,\n              nativeCurrency:\n                addEthereumChainParameter?.nativeCurrency ??\n                chain.nativeCurrency,\n              rpcUrls,\n            } satisfies AddEthereumChainParameter\n\n            await provider.request({\n              method: 'wallet_addEthereumChain',\n              params: [addEthereumChain],\n            })\n\n            return chain\n          } catch (error) {\n            throw new UserRejectedRequestError(error as Error)\n          }\n        }\n\n        throw new SwitchChainError(error as Error)\n      }\n    },\n    onAccountsChanged(accounts) {\n      if (accounts.length === 0) this.onDisconnect()\n      else\n        config.emitter.emit('change', {\n          accounts: accounts.map((x) => getAddress(x)),\n        })\n    },\n    onChainChanged(chain) {\n      const chainId = Number(chain)\n      config.emitter.emit('change', { chainId })\n    },\n    async onDisconnect(_error) {\n      config.emitter.emit('disconnect')\n\n      const provider = await this.getProvider()\n      if (accountsChanged) {\n        provider.removeListener('accountsChanged', accountsChanged)\n        accountsChanged = undefined\n      }\n      if (chainChanged) {\n        provider.removeListener('chainChanged', chainChanged)\n        chainChanged = undefined\n      }\n      if (disconnect) {\n        provider.removeListener('disconnect', disconnect)\n        disconnect = undefined\n      }\n    },\n  }))\n}\n\ntype Version3Parameters = Mutable<\n  Omit<\n    ConstructorParameters<typeof CBW_SDK>[0],\n    'reloadOnDisconnect' // remove property since TSDoc says default is `true`\n  >\n> & {\n  /**\n   * Fallback Ethereum JSON RPC URL\n   * @default \"\"\n   */\n  jsonRpcUrl?: string | undefined\n  /**\n   * Fallback Ethereum Chain ID\n   * @default 1\n   */\n  chainId?: number | undefined\n  /**\n   * Whether or not to reload dapp automatically after disconnect.\n   * @default false\n   */\n  reloadOnDisconnect?: boolean | undefined\n}\n\nfunction version3(parameters: Version3Parameters) {\n  const reloadOnDisconnect = false\n\n  type Provider = CBW_Provider\n\n  let sdk: CBW_SDK | undefined\n  let walletProvider: Provider | undefined\n\n  let accountsChanged: Connector['onAccountsChanged'] | undefined\n  let chainChanged: Connector['onChainChanged'] | undefined\n  let disconnect: Connector['onDisconnect'] | undefined\n\n  return createConnector<Provider>((config) => ({\n    id: 'coinbaseWalletSDK',\n    name: 'Coinbase Wallet',\n    rdns: 'com.coinbase.wallet',\n    type: coinbaseWallet.type,\n    async connect({ chainId, withCapabilities } = {}) {\n      try {\n        const provider = await this.getProvider()\n        const accounts = (\n          (await provider.request({\n            method: 'eth_requestAccounts',\n          })) as string[]\n        ).map((x) => getAddress(x))\n\n        if (!accountsChanged) {\n          accountsChanged = this.onAccountsChanged.bind(this)\n          provider.on('accountsChanged', accountsChanged)\n        }\n        if (!chainChanged) {\n          chainChanged = this.onChainChanged.bind(this)\n          provider.on('chainChanged', chainChanged)\n        }\n        if (!disconnect) {\n          disconnect = this.onDisconnect.bind(this)\n          provider.on('disconnect', disconnect)\n        }\n\n        // Switch to chain if provided\n        let currentChainId = await this.getChainId()\n        if (chainId && currentChainId !== chainId) {\n          const chain = await this.switchChain!({ chainId }).catch((error) => {\n            if (error.code === UserRejectedRequestError.code) throw error\n            return { id: currentChainId }\n          })\n          currentChainId = chain?.id ?? currentChainId\n        }\n\n        return {\n          accounts: (withCapabilities\n            ? accounts.map((address) => ({ address, capabilities: {} }))\n            : accounts) as never,\n          chainId: currentChainId,\n        }\n      } catch (error) {\n        if (\n          /(user closed modal|accounts received is empty|user denied account)/i.test(\n            (error as Error).message,\n          )\n        )\n          throw new UserRejectedRequestError(error as Error)\n        throw error\n      }\n    },\n    async disconnect() {\n      const provider = await this.getProvider()\n\n      if (accountsChanged) {\n        provider.removeListener('accountsChanged', accountsChanged)\n        accountsChanged = undefined\n      }\n      if (chainChanged) {\n        provider.removeListener('chainChanged', chainChanged)\n        chainChanged = undefined\n      }\n      if (disconnect) {\n        provider.removeListener('disconnect', disconnect)\n        disconnect = undefined\n      }\n\n      provider.disconnect()\n      provider.close()\n    },\n    async getAccounts() {\n      const provider = await this.getProvider()\n      return (\n        await provider.request<string[]>({\n          method: 'eth_accounts',\n        })\n      ).map((x) => getAddress(x))\n    },\n    async getChainId() {\n      const provider = await this.getProvider()\n      const chainId = await provider.request<Hex>({\n        method: 'eth_chainId',\n      })\n      return Number(chainId)\n    },\n    async getProvider() {\n      if (!walletProvider) {\n        // Unwrapping import for Vite compatibility.\n        // See: https://github.com/vitejs/vite/issues/9703\n        const CoinbaseWalletSDK = await (async () => {\n          const { default: SDK } = await import('cbw-sdk')\n          if (typeof SDK !== 'function' && typeof SDK.default === 'function')\n            return SDK.default\n          return SDK as unknown as typeof SDK.default\n        })()\n\n        sdk = new CoinbaseWalletSDK({ ...parameters, reloadOnDisconnect })\n\n        // Force types to retrieve private `walletExtension` method from the Coinbase Wallet SDK.\n        const walletExtensionChainId = (\n          sdk as unknown as {\n            get walletExtension(): { getChainId(): number } | undefined\n          }\n        ).walletExtension?.getChainId()\n\n        const chain =\n          config.chains.find((chain) =>\n            parameters.chainId\n              ? chain.id === parameters.chainId\n              : chain.id === walletExtensionChainId,\n          ) || config.chains[0]\n        const chainId = parameters.chainId || chain?.id\n        const jsonRpcUrl =\n          parameters.jsonRpcUrl || chain?.rpcUrls.default.http[0]\n\n        walletProvider = sdk.makeWeb3Provider(jsonRpcUrl, chainId)\n      }\n\n      return walletProvider\n    },\n    async isAuthorized() {\n      try {\n        const accounts = await this.getAccounts()\n        return !!accounts.length\n      } catch {\n        return false\n      }\n    },\n    async switchChain({ addEthereumChainParameter, chainId }) {\n      const chain = config.chains.find((chain) => chain.id === chainId)\n      if (!chain) throw new SwitchChainError(new ChainNotConfiguredError())\n\n      const provider = await this.getProvider()\n\n      try {\n        await provider.request({\n          method: 'wallet_switchEthereumChain',\n          params: [{ chainId: numberToHex(chain.id) }],\n        })\n        return chain\n      } catch (error) {\n        // Indicates chain is not added to provider\n        if ((error as ProviderRpcError).code === 4902) {\n          try {\n            let blockExplorerUrls: string[] | undefined\n            if (addEthereumChainParameter?.blockExplorerUrls)\n              blockExplorerUrls = addEthereumChainParameter.blockExplorerUrls\n            else\n              blockExplorerUrls = chain.blockExplorers?.default.url\n                ? [chain.blockExplorers?.default.url]\n                : []\n\n            let rpcUrls: readonly string[]\n            if (addEthereumChainParameter?.rpcUrls?.length)\n              rpcUrls = addEthereumChainParameter.rpcUrls\n            else rpcUrls = [chain.rpcUrls.default?.http[0] ?? '']\n\n            const addEthereumChain = {\n              blockExplorerUrls,\n              chainId: numberToHex(chainId),\n              chainName: addEthereumChainParameter?.chainName ?? chain.name,\n              iconUrls: addEthereumChainParameter?.iconUrls,\n              nativeCurrency:\n                addEthereumChainParameter?.nativeCurrency ??\n                chain.nativeCurrency,\n              rpcUrls,\n            } satisfies AddEthereumChainParameter\n\n            await provider.request({\n              method: 'wallet_addEthereumChain',\n              params: [addEthereumChain],\n            })\n\n            return chain\n          } catch (error) {\n            throw new UserRejectedRequestError(error as Error)\n          }\n        }\n\n        throw new SwitchChainError(error as Error)\n      }\n    },\n    onAccountsChanged(accounts) {\n      if (accounts.length === 0) this.onDisconnect()\n      else\n        config.emitter.emit('change', {\n          accounts: accounts.map((x) => getAddress(x)),\n        })\n    },\n    onChainChanged(chain) {\n      const chainId = Number(chain)\n      config.emitter.emit('change', { chainId })\n    },\n    async onDisconnect(_error) {\n      config.emitter.emit('disconnect')\n\n      const provider = await this.getProvider()\n      if (accountsChanged) {\n        provider.removeListener('accountsChanged', accountsChanged)\n        accountsChanged = undefined\n      }\n      if (chainChanged) {\n        provider.removeListener('chainChanged', chainChanged)\n        chainChanged = undefined\n      }\n      if (disconnect) {\n        provider.removeListener('disconnect', disconnect)\n        disconnect = undefined\n      }\n    },\n  }))\n}\n","import type { PartializedState } from './createConfig.js'\nimport type { Compute } from './types/utils.js'\nimport { deserialize as deserialize_ } from './utils/deserialize.js'\nimport { serialize as serialize_ } from './utils/serialize.js'\n\n// key-values for loose autocomplete and typing\nexport type StorageItemMap = {\n  recentConnectorId: string\n  state: PartializedState\n}\n\nexport type Storage<\n  itemMap extends Record<string, unknown> = Record<string, unknown>,\n  ///\n  storageItemMap extends StorageItemMap = StorageItemMap & itemMap,\n> = {\n  key: string\n  getItem<\n    key extends keyof storageItemMap,\n    value extends storageItemMap[key],\n    defaultValue extends value | null | undefined,\n  >(\n    key: key,\n    defaultValue?: defaultValue | undefined,\n  ):\n    | (defaultValue extends null ? value | null : value)\n    | Promise<defaultValue extends null ? value | null : value>\n  setItem<\n    key extends keyof storageItemMap,\n    value extends storageItemMap[key] | null,\n  >(key: key, value: value): void | Promise<void>\n  removeItem(key: keyof storageItemMap): void | Promise<void>\n}\n\nexport type BaseStorage = {\n  getItem(\n    key: string,\n  ): string | null | undefined | Promise<string | null | undefined>\n  setItem(key: string, value: string): void | Promise<void>\n  removeItem(key: string): void | Promise<void>\n}\n\nexport type CreateStorageParameters = {\n  deserialize?: (<type>(value: string) => type | unknown) | undefined\n  key?: string | undefined\n  serialize?: (<type>(value: type | any) => string) | undefined\n  storage?: Compute<BaseStorage> | undefined\n}\n\nexport function createStorage<\n  itemMap extends Record<string, unknown> = Record<string, unknown>,\n  storageItemMap extends StorageItemMap = StorageItemMap & itemMap,\n>(parameters: CreateStorageParameters): Compute<Storage<storageItemMap>> {\n  const {\n    deserialize = deserialize_,\n    key: prefix = 'wagmi',\n    serialize = serialize_,\n    storage = noopStorage,\n  } = parameters\n\n  function unwrap<type>(value: type): type | Promise<type> {\n    if (value instanceof Promise) return value.then((x) => x).catch(() => null)\n    return value\n  }\n\n  return {\n    ...storage,\n    key: prefix,\n    async getItem(key, defaultValue) {\n      const value = storage.getItem(`${prefix}.${key as string}`)\n      const unwrapped = await unwrap(value)\n      if (unwrapped) return deserialize(unwrapped) ?? null\n      return (defaultValue ?? null) as any\n    },\n    async setItem(key, value) {\n      const storageKey = `${prefix}.${key as string}`\n      if (value === null) await unwrap(storage.removeItem(storageKey))\n      else await unwrap(storage.setItem(storageKey, serialize(value)))\n    },\n    async removeItem(key) {\n      await unwrap(storage.removeItem(`${prefix}.${key as string}`))\n    },\n  }\n}\n\nexport const noopStorage = {\n  getItem: () => null,\n  setItem: () => {},\n  removeItem: () => {},\n} satisfies BaseStorage\n\nexport function getDefaultStorage() {\n  const storage = (() => {\n    // biome-ignore lint/complexity/useOptionalChain: _\n    if (typeof window !== 'undefined' && window.localStorage)\n      return window.localStorage\n    return noopStorage\n  })()\n  return {\n    getItem(key) {\n      return storage.getItem(key)\n    },\n    removeItem(key) {\n      storage.removeItem(key)\n    },\n    setItem(key, value) {\n      try {\n        storage.setItem(key, value)\n        // silence errors by default (QuotaExceededError, SecurityError, etc.)\n      } catch {}\n    },\n  } satisfies BaseStorage\n}\n","import { EventEmitter } from 'eventemitter3'\n\ntype EventMap = Record<string, object | never>\ntype EventKey<eventMap extends EventMap> = string & keyof eventMap\ntype EventFn<parameters extends unknown[] = any[]> = (\n  ...parameters: parameters\n) => void\nexport type EventData<\n  eventMap extends EventMap,\n  eventName extends keyof eventMap,\n> = (eventMap[eventName] extends [never] ? unknown : eventMap[eventName]) & {\n  uid: string\n}\n\nexport class Emitter<eventMap extends EventMap> {\n  _emitter = new EventEmitter()\n\n  constructor(public uid: string) {}\n\n  on<key extends EventKey<eventMap>>(\n    eventName: key,\n    fn: EventFn<\n      eventMap[key] extends [never]\n        ? [{ uid: string }]\n        : [data: eventMap[key] & { uid: string }]\n    >,\n  ) {\n    this._emitter.on(eventName, fn as EventFn)\n  }\n\n  once<key extends EventKey<eventMap>>(\n    eventName: key,\n    fn: EventFn<\n      eventMap[key] extends [never]\n        ? [{ uid: string }]\n        : [data: eventMap[key] & { uid: string }]\n    >,\n  ) {\n    this._emitter.once(eventName, fn as EventFn)\n  }\n\n  off<key extends EventKey<eventMap>>(\n    eventName: key,\n    fn: EventFn<\n      eventMap[key] extends [never]\n        ? [{ uid: string }]\n        : [data: eventMap[key] & { uid: string }]\n    >,\n  ) {\n    this._emitter.off(eventName, fn as EventFn)\n  }\n\n  emit<key extends EventKey<eventMap>>(\n    eventName: key,\n    ...params: eventMap[key] extends [never] ? [] : [data: eventMap[key]]\n  ) {\n    const data = params[0]\n    this._emitter.emit(eventName, { uid: this.uid, ...data })\n  }\n\n  listenerCount<key extends EventKey<eventMap>>(eventName: key) {\n    return this._emitter.listenerCount(eventName)\n  }\n}\n\nexport function createEmitter<eventMap extends EventMap>(uid: string) {\n  return new Emitter<eventMap>(uid)\n}\n","import type {\n  AddEthereumChainParameter,\n  Address,\n  Chain,\n  Client,\n  ProviderConnectInfo,\n  ProviderMessage,\n} from 'viem'\n\nimport type { Transport } from '../createConfig.js'\nimport type { Emitter } from '../createEmitter.js'\nimport type { Storage } from '../createStorage.js'\nimport type { Compute, ExactPartial, StrictOmit } from '../types/utils.js'\n\nexport type ConnectorEventMap = {\n  change: {\n    accounts?: readonly Address[] | undefined\n    chainId?: number | undefined\n  }\n  connect: { accounts: readonly Address[]; chainId: number }\n  disconnect: never\n  error: { error: Error }\n  message: { type: string; data?: unknown | undefined }\n}\n\nexport type CreateConnectorFn<\n  provider = unknown,\n  properties extends Record<string, unknown> = Record<string, unknown>,\n  storageItem extends Record<string, unknown> = Record<string, unknown>,\n> = (config: {\n  chains: readonly [Chain, ...Chain[]]\n  emitter: Emitter<ConnectorEventMap>\n  storage?: Compute<Storage<storageItem>> | null | undefined\n  transports?: Record<number, Transport> | undefined\n}) => Compute<\n  {\n    readonly icon?: string | undefined\n    readonly id: string\n    readonly name: string\n    readonly rdns?: string | readonly string[] | undefined\n    /** @deprecated */\n    readonly supportsSimulation?: boolean | undefined\n    readonly type: string\n\n    setup?(): Promise<void>\n    // TODO(v3): Make `withCapabilities: true` default behavior\n    connect<withCapabilities extends boolean = false>(\n      parameters?:\n        | {\n            chainId?: number | undefined\n            isReconnecting?: boolean | undefined\n            withCapabilities?: withCapabilities | boolean | undefined\n          }\n        | undefined,\n    ): Promise<{\n      // TODO(v3): Add `capabilities` (e.g. `readonly { address: Address; capabilities: Record<string, unknown> | undefined }`)\n      accounts: withCapabilities extends true\n        ? readonly { address: Address; capabilities: Record<string, unknown> }[]\n        : readonly Address[]\n      chainId: number\n    }>\n    disconnect(): Promise<void>\n    getAccounts(): Promise<readonly Address[]>\n    getChainId(): Promise<number>\n    getProvider(\n      parameters?: { chainId?: number | undefined } | undefined,\n    ): Promise<provider>\n    getClient?(\n      parameters?: { chainId?: number | undefined } | undefined,\n    ): Promise<Client>\n    isAuthorized(): Promise<boolean>\n    switchChain?(\n      parameters: Compute<{\n        addEthereumChainParameter?:\n          | ExactPartial<StrictOmit<AddEthereumChainParameter, 'chainId'>>\n          | undefined\n        chainId: number\n      }>,\n    ): Promise<Chain>\n\n    onAccountsChanged(accounts: string[]): void\n    onChainChanged(chainId: string): void\n    onConnect?(connectInfo: ProviderConnectInfo): void\n    onDisconnect(error?: Error | undefined): void\n    onMessage?(message: ProviderMessage): void\n  } & properties\n>\n\nexport function createConnector<\n  provider,\n  properties extends Record<string, unknown> = Record<string, unknown>,\n  storageItem extends Record<string, unknown> = Record<string, unknown>,\n  ///\n  createConnectorFn extends CreateConnectorFn<\n    provider,\n    properties,\n    storageItem\n  > = CreateConnectorFn<provider, properties, storageItem>,\n>(createConnectorFn: createConnectorFn) {\n  return createConnectorFn\n}\n","import { defineChain } from '../../utils/chain/defineChain.js'\n\nexport const mainnet = /*#__PURE__*/ defineChain({\n  id: 1,\n  name: 'Ethereum',\n  nativeCurrency: { name: 'Ether', symbol: 'ETH', decimals: 18 },\n  blockTime: 12_000,\n  rpcUrls: {\n    default: {\n      http: ['https://eth.merkle.io'],\n    },\n  },\n  blockExplorers: {\n    default: {\n      name: 'Etherscan',\n      url: 'https://etherscan.io',\n      apiUrl: 'https://api.etherscan.io/api',\n    },\n  },\n  contracts: {\n    ensUniversalResolver: {\n      address: '0xeeeeeeee14d718c2b47d9923deab1335e144eeee',\n      blockCreated: 23_085_558,\n    },\n    multicall3: {\n      address: '0xca11bde05977b3631167028862be2a173976ca11',\n      blockCreated: 14_353_601,\n    },\n  },\n})\n","import { chainConfig } from '../../op-stack/chainConfig.js'\nimport { defineChain } from '../../utils/chain/defineChain.js'\n\nconst sourceId = 11_155_111 // sepolia\n\nexport const baseSepolia = /*#__PURE__*/ defineChain({\n  ...chainConfig,\n  id: 84532,\n  network: 'base-sepolia',\n  name: 'Base Sepolia',\n  nativeCurrency: { name: 'Sepolia Ether', symbol: 'ETH', decimals: 18 },\n  rpcUrls: {\n    default: {\n      http: ['https://sepolia.base.org'],\n    },\n  },\n  blockExplorers: {\n    default: {\n      name: 'Basescan',\n      url: 'https://sepolia.basescan.org',\n      apiUrl: 'https://api-sepolia.basescan.org/api',\n    },\n  },\n  contracts: {\n    ...chainConfig.contracts,\n    disputeGameFactory: {\n      [sourceId]: {\n        address: '0xd6E6dBf4F7EA0ac412fD8b65ED297e64BB7a06E1',\n      },\n    },\n    l2OutputOracle: {\n      [sourceId]: {\n        address: '0x84457ca9D0163FbC4bbfe4Dfbb20ba46e48DF254',\n      },\n    },\n    portal: {\n      [sourceId]: {\n        address: '0x49f53e41452c74589e85ca1677426ba426459e85',\n        blockCreated: 4446677,\n      },\n    },\n    l1StandardBridge: {\n      [sourceId]: {\n        address: '0xfd0Bf71F60660E2f608ed56e1659C450eB113120',\n        blockCreated: 4446677,\n      },\n    },\n    multicall3: {\n      address: '0xca11bde05977b3631167028862be2a173976ca11',\n      blockCreated: 1059647,\n    },\n  },\n  testnet: true,\n  sourceId,\n})\n\nexport const baseSepoliaPreconf = /*#__PURE__*/ defineChain({\n  ...baseSepolia,\n  experimental_preconfirmationTime: 200,\n  rpcUrls: {\n    default: {\n      http: ['https://sepolia-preconf.base.org'],\n    },\n  },\n})\n","import { hashQueryKeyByOptions, matchQuery } from './utils'\nimport { Query } from './query'\nimport { notifyManager } from './notifyManager'\nimport { Subscribable } from './subscribable'\nimport type { QueryFilters } from './utils'\nimport type { Action, QueryState } from './query'\nimport type {\n  DefaultError,\n  NotifyEvent,\n  QueryKey,\n  QueryOptions,\n  WithRequired,\n} from './types'\nimport type { QueryClient } from './queryClient'\nimport type { QueryObserver } from './queryObserver'\n\n// TYPES\n\ninterface QueryCacheConfig {\n  onError?: (\n    error: DefaultError,\n    query: Query<unknown, unknown, unknown>,\n  ) => void\n  onSuccess?: (data: unknown, query: Query<unknown, unknown, unknown>) => void\n  onSettled?: (\n    data: unknown | undefined,\n    error: DefaultError | null,\n    query: Query<unknown, unknown, unknown>,\n  ) => void\n}\n\ninterface NotifyEventQueryAdded extends NotifyEvent {\n  type: 'added'\n  query: Query<any, any, any, any>\n}\n\ninterface NotifyEventQueryRemoved extends NotifyEvent {\n  type: 'removed'\n  query: Query<any, any, any, any>\n}\n\ninterface NotifyEventQueryUpdated extends NotifyEvent {\n  type: 'updated'\n  query: Query<any, any, any, any>\n  action: Action<any, any>\n}\n\ninterface NotifyEventQueryObserverAdded extends NotifyEvent {\n  type: 'observerAdded'\n  query: Query<any, any, any, any>\n  observer: QueryObserver<any, any, any, any, any>\n}\n\ninterface NotifyEventQueryObserverRemoved extends NotifyEvent {\n  type: 'observerRemoved'\n  query: Query<any, any, any, any>\n  observer: QueryObserver<any, any, any, any, any>\n}\n\ninterface NotifyEventQueryObserverResultsUpdated extends NotifyEvent {\n  type: 'observerResultsUpdated'\n  query: Query<any, any, any, any>\n}\n\ninterface NotifyEventQueryObserverOptionsUpdated extends NotifyEvent {\n  type: 'observerOptionsUpdated'\n  query: Query<any, any, any, any>\n  observer: QueryObserver<any, any, any, any, any>\n}\n\nexport type QueryCacheNotifyEvent =\n  | NotifyEventQueryAdded\n  | NotifyEventQueryRemoved\n  | NotifyEventQueryUpdated\n  | NotifyEventQueryObserverAdded\n  | NotifyEventQueryObserverRemoved\n  | NotifyEventQueryObserverResultsUpdated\n  | NotifyEventQueryObserverOptionsUpdated\n\ntype QueryCacheListener = (event: QueryCacheNotifyEvent) => void\n\nexport interface QueryStore {\n  has: (queryHash: string) => boolean\n  set: (queryHash: string, query: Query) => void\n  get: (queryHash: string) => Query | undefined\n  delete: (queryHash: string) => void\n  values: () => IterableIterator<Query>\n}\n\n// CLASS\n\nexport class QueryCache extends Subscribable<QueryCacheListener> {\n  #queries: QueryStore\n\n  constructor(public config: QueryCacheConfig = {}) {\n    super()\n    this.#queries = new Map<string, Query>()\n  }\n\n  build<\n    TQueryFnData = unknown,\n    TError = DefaultError,\n    TData = TQueryFnData,\n    TQueryKey extends QueryKey = QueryKey,\n  >(\n    client: QueryClient,\n    options: WithRequired<\n      QueryOptions<TQueryFnData, TError, TData, TQueryKey>,\n      'queryKey'\n    >,\n    state?: QueryState<TData, TError>,\n  ): Query<TQueryFnData, TError, TData, TQueryKey> {\n    const queryKey = options.queryKey\n    const queryHash =\n      options.queryHash ?? hashQueryKeyByOptions(queryKey, options)\n    let query = this.get<TQueryFnData, TError, TData, TQueryKey>(queryHash)\n\n    if (!query) {\n      query = new Query({\n        client,\n        queryKey,\n        queryHash,\n        options: client.defaultQueryOptions(options),\n        state,\n        defaultOptions: client.getQueryDefaults(queryKey),\n      })\n      this.add(query)\n    }\n\n    return query\n  }\n\n  add(query: Query<any, any, any, any>): void {\n    if (!this.#queries.has(query.queryHash)) {\n      this.#queries.set(query.queryHash, query)\n\n      this.notify({\n        type: 'added',\n        query,\n      })\n    }\n  }\n\n  remove(query: Query<any, any, any, any>): void {\n    const queryInMap = this.#queries.get(query.queryHash)\n\n    if (queryInMap) {\n      query.destroy()\n\n      if (queryInMap === query) {\n        this.#queries.delete(query.queryHash)\n      }\n\n      this.notify({ type: 'removed', query })\n    }\n  }\n\n  clear(): void {\n    notifyManager.batch(() => {\n      this.getAll().forEach((query) => {\n        this.remove(query)\n      })\n    })\n  }\n\n  get<\n    TQueryFnData = unknown,\n    TError = DefaultError,\n    TData = TQueryFnData,\n    TQueryKey extends QueryKey = QueryKey,\n  >(\n    queryHash: string,\n  ): Query<TQueryFnData, TError, TData, TQueryKey> | undefined {\n    return this.#queries.get(queryHash) as\n      | Query<TQueryFnData, TError, TData, TQueryKey>\n      | undefined\n  }\n\n  getAll(): Array<Query> {\n    return [...this.#queries.values()]\n  }\n\n  find<TQueryFnData = unknown, TError = DefaultError, TData = TQueryFnData>(\n    filters: WithRequired<QueryFilters, 'queryKey'>,\n  ): Query<TQueryFnData, TError, TData> | undefined {\n    const defaultedFilters = { exact: true, ...filters }\n\n    return this.getAll().find((query) =>\n      matchQuery(defaultedFilters, query),\n    ) as Query<TQueryFnData, TError, TData> | undefined\n  }\n\n  findAll(filters: QueryFilters<any> = {}): Array<Query> {\n    const queries = this.getAll()\n    return Object.keys(filters).length > 0\n      ? queries.filter((query) => matchQuery(filters, query))\n      : queries\n  }\n\n  notify(event: QueryCacheNotifyEvent): void {\n    notifyManager.batch(() => {\n      this.listeners.forEach((listener) => {\n        listener(event)\n      })\n    })\n  }\n\n  onFocus(): void {\n    notifyManager.batch(() => {\n      this.getAll().forEach((query) => {\n        query.onFocus()\n      })\n    })\n  }\n\n  onOnline(): void {\n    notifyManager.batch(() => {\n      this.getAll().forEach((query) => {\n        query.onOnline()\n      })\n    })\n  }\n}\n","// src/queryCache.ts\nimport { hashQueryKeyByOptions, matchQuery } from \"./utils.js\";\nimport { Query } from \"./query.js\";\nimport { notifyManager } from \"./notifyManager.js\";\nimport { Subscribable } from \"./subscribable.js\";\nvar QueryCache = class extends Subscribable {\n  constructor(config = {}) {\n    super();\n    this.config = config;\n    this.#queries = /* @__PURE__ */ new Map();\n  }\n  #queries;\n  build(client, options, state) {\n    const queryKey = options.queryKey;\n    const queryHash = options.queryHash ?? hashQueryKeyByOptions(queryKey, options);\n    let query = this.get(queryHash);\n    if (!query) {\n      query = new Query({\n        client,\n        queryKey,\n        queryHash,\n        options: client.defaultQueryOptions(options),\n        state,\n        defaultOptions: client.getQueryDefaults(queryKey)\n      });\n      this.add(query);\n    }\n    return query;\n  }\n  add(query) {\n    if (!this.#queries.has(query.queryHash)) {\n      this.#queries.set(query.queryHash, query);\n      this.notify({\n        type: \"added\",\n        query\n      });\n    }\n  }\n  remove(query) {\n    const queryInMap = this.#queries.get(query.queryHash);\n    if (queryInMap) {\n      query.destroy();\n      if (queryInMap === query) {\n        this.#queries.delete(query.queryHash);\n      }\n      this.notify({ type: \"removed\", query });\n    }\n  }\n  clear() {\n    notifyManager.batch(() => {\n      this.getAll().forEach((query) => {\n        this.remove(query);\n      });\n    });\n  }\n  get(queryHash) {\n    return this.#queries.get(queryHash);\n  }\n  getAll() {\n    return [...this.#queries.values()];\n  }\n  find(filters) {\n    const defaultedFilters = { exact: true, ...filters };\n    return this.getAll().find(\n      (query) => matchQuery(defaultedFilters, query)\n    );\n  }\n  findAll(filters = {}) {\n    const queries = this.getAll();\n    return Object.keys(filters).length > 0 ? queries.filter((query) => matchQuery(filters, query)) : queries;\n  }\n  notify(event) {\n    notifyManager.batch(() => {\n      this.listeners.forEach((listener) => {\n        listener(event);\n      });\n    });\n  }\n  onFocus() {\n    notifyManager.batch(() => {\n      this.getAll().forEach((query) => {\n        query.onFocus();\n      });\n    });\n  }\n  onOnline() {\n    notifyManager.batch(() => {\n      this.getAll().forEach((query) => {\n        query.onOnline();\n      });\n    });\n  }\n};\nexport {\n  QueryCache\n};\n//# sourceMappingURL=queryCache.js.map","// src/mutationCache.ts\nimport { notifyManager } from \"./notifyManager.js\";\nimport { Mutation } from \"./mutation.js\";\nimport { matchMutation, noop } from \"./utils.js\";\nimport { Subscribable } from \"./subscribable.js\";\nvar MutationCache = class extends Subscribable {\n  constructor(config = {}) {\n    super();\n    this.config = config;\n    this.#mutations = /* @__PURE__ */ new Set();\n    this.#scopes = /* @__PURE__ */ new Map();\n    this.#mutationId = 0;\n  }\n  #mutations;\n  #scopes;\n  #mutationId;\n  build(client, options, state) {\n    const mutation = new Mutation({\n      client,\n      mutationCache: this,\n      mutationId: ++this.#mutationId,\n      options: client.defaultMutationOptions(options),\n      state\n    });\n    this.add(mutation);\n    return mutation;\n  }\n  add(mutation) {\n    this.#mutations.add(mutation);\n    const scope = scopeFor(mutation);\n    if (typeof scope === \"string\") {\n      const scopedMutations = this.#scopes.get(scope);\n      if (scopedMutations) {\n        scopedMutations.push(mutation);\n      } else {\n        this.#scopes.set(scope, [mutation]);\n      }\n    }\n    this.notify({ type: \"added\", mutation });\n  }\n  remove(mutation) {\n    if (this.#mutations.delete(mutation)) {\n      const scope = scopeFor(mutation);\n      if (typeof scope === \"string\") {\n        const scopedMutations = this.#scopes.get(scope);\n        if (scopedMutations) {\n          if (scopedMutations.length > 1) {\n            const index = scopedMutations.indexOf(mutation);\n            if (index !== -1) {\n              scopedMutations.splice(index, 1);\n            }\n          } else if (scopedMutations[0] === mutation) {\n            this.#scopes.delete(scope);\n          }\n        }\n      }\n    }\n    this.notify({ type: \"removed\", mutation });\n  }\n  canRun(mutation) {\n    const scope = scopeFor(mutation);\n    if (typeof scope === \"string\") {\n      const mutationsWithSameScope = this.#scopes.get(scope);\n      const firstPendingMutation = mutationsWithSameScope?.find(\n        (m) => m.state.status === \"pending\"\n      );\n      return !firstPendingMutation || firstPendingMutation === mutation;\n    } else {\n      return true;\n    }\n  }\n  runNext(mutation) {\n    const scope = scopeFor(mutation);\n    if (typeof scope === \"string\") {\n      const foundMutation = this.#scopes.get(scope)?.find((m) => m !== mutation && m.state.isPaused);\n      return foundMutation?.continue() ?? Promise.resolve();\n    } else {\n      return Promise.resolve();\n    }\n  }\n  clear() {\n    notifyManager.batch(() => {\n      this.#mutations.forEach((mutation) => {\n        this.notify({ type: \"removed\", mutation });\n      });\n      this.#mutations.clear();\n      this.#scopes.clear();\n    });\n  }\n  getAll() {\n    return Array.from(this.#mutations);\n  }\n  find(filters) {\n    const defaultedFilters = { exact: true, ...filters };\n    return this.getAll().find(\n      (mutation) => matchMutation(defaultedFilters, mutation)\n    );\n  }\n  findAll(filters = {}) {\n    return this.getAll().filter((mutation) => matchMutation(filters, mutation));\n  }\n  notify(event) {\n    notifyManager.batch(() => {\n      this.listeners.forEach((listener) => {\n        listener(event);\n      });\n    });\n  }\n  resumePausedMutations() {\n    const pausedMutations = this.getAll().filter((x) => x.state.isPaused);\n    return notifyManager.batch(\n      () => Promise.all(\n        pausedMutations.map((mutation) => mutation.continue().catch(noop))\n      )\n    );\n  }\n};\nfunction scopeFor(mutation) {\n  return mutation.options.scope?.id;\n}\nexport {\n  MutationCache\n};\n//# sourceMappingURL=mutationCache.js.map","import { notifyManager } from './notifyManager'\nimport { Mutation } from './mutation'\nimport { matchMutation, noop } from './utils'\nimport { Subscribable } from './subscribable'\nimport type { MutationObserver } from './mutationObserver'\nimport type {\n  DefaultError,\n  MutationFunctionContext,\n  MutationOptions,\n  NotifyEvent,\n} from './types'\nimport type { QueryClient } from './queryClient'\nimport type { Action, MutationState } from './mutation'\nimport type { MutationFilters } from './utils'\n\n// TYPES\n\ninterface MutationCacheConfig {\n  onError?: (\n    error: DefaultError,\n    variables: unknown,\n    onMutateResult: unknown,\n    mutation: Mutation<unknown, unknown, unknown>,\n    context: MutationFunctionContext,\n  ) => Promise<unknown> | unknown\n  onSuccess?: (\n    data: unknown,\n    variables: unknown,\n    onMutateResult: unknown,\n    mutation: Mutation<unknown, unknown, unknown>,\n    context: MutationFunctionContext,\n  ) => Promise<unknown> | unknown\n  onMutate?: (\n    variables: unknown,\n    mutation: Mutation<unknown, unknown, unknown>,\n    context: MutationFunctionContext,\n  ) => Promise<unknown> | unknown\n  onSettled?: (\n    data: unknown | undefined,\n    error: DefaultError | null,\n    variables: unknown,\n    onMutateResult: unknown,\n    mutation: Mutation<unknown, unknown, unknown>,\n    context: MutationFunctionContext,\n  ) => Promise<unknown> | unknown\n}\n\ninterface NotifyEventMutationAdded extends NotifyEvent {\n  type: 'added'\n  mutation: Mutation<any, any, any, any>\n}\ninterface NotifyEventMutationRemoved extends NotifyEvent {\n  type: 'removed'\n  mutation: Mutation<any, any, any, any>\n}\n\ninterface NotifyEventMutationObserverAdded extends NotifyEvent {\n  type: 'observerAdded'\n  mutation: Mutation<any, any, any, any>\n  observer: MutationObserver<any, any, any>\n}\n\ninterface NotifyEventMutationObserverRemoved extends NotifyEvent {\n  type: 'observerRemoved'\n  mutation: Mutation<any, any, any, any>\n  observer: MutationObserver<any, any, any>\n}\n\ninterface NotifyEventMutationObserverOptionsUpdated extends NotifyEvent {\n  type: 'observerOptionsUpdated'\n  mutation?: Mutation<any, any, any, any>\n  observer: MutationObserver<any, any, any, any>\n}\n\ninterface NotifyEventMutationUpdated extends NotifyEvent {\n  type: 'updated'\n  mutation: Mutation<any, any, any, any>\n  action: Action<any, any, any, any>\n}\n\nexport type MutationCacheNotifyEvent =\n  | NotifyEventMutationAdded\n  | NotifyEventMutationRemoved\n  | NotifyEventMutationObserverAdded\n  | NotifyEventMutationObserverRemoved\n  | NotifyEventMutationObserverOptionsUpdated\n  | NotifyEventMutationUpdated\n\ntype MutationCacheListener = (event: MutationCacheNotifyEvent) => void\n\n// CLASS\n\nexport class MutationCache extends Subscribable<MutationCacheListener> {\n  #mutations: Set<Mutation<any, any, any, any>>\n  #scopes: Map<string, Array<Mutation<any, any, any, any>>>\n  #mutationId: number\n\n  constructor(public config: MutationCacheConfig = {}) {\n    super()\n    this.#mutations = new Set()\n    this.#scopes = new Map()\n    this.#mutationId = 0\n  }\n\n  build<TData, TError, TVariables, TOnMutateResult>(\n    client: QueryClient,\n    options: MutationOptions<TData, TError, TVariables, TOnMutateResult>,\n    state?: MutationState<TData, TError, TVariables, TOnMutateResult>,\n  ): Mutation<TData, TError, TVariables, TOnMutateResult> {\n    const mutation = new Mutation({\n      client,\n      mutationCache: this,\n      mutationId: ++this.#mutationId,\n      options: client.defaultMutationOptions(options),\n      state,\n    })\n\n    this.add(mutation)\n\n    return mutation\n  }\n\n  add(mutation: Mutation<any, any, any, any>): void {\n    this.#mutations.add(mutation)\n    const scope = scopeFor(mutation)\n    if (typeof scope === 'string') {\n      const scopedMutations = this.#scopes.get(scope)\n      if (scopedMutations) {\n        scopedMutations.push(mutation)\n      } else {\n        this.#scopes.set(scope, [mutation])\n      }\n    }\n    this.notify({ type: 'added', mutation })\n  }\n\n  remove(mutation: Mutation<any, any, any, any>): void {\n    if (this.#mutations.delete(mutation)) {\n      const scope = scopeFor(mutation)\n      if (typeof scope === 'string') {\n        const scopedMutations = this.#scopes.get(scope)\n        if (scopedMutations) {\n          if (scopedMutations.length > 1) {\n            const index = scopedMutations.indexOf(mutation)\n            if (index !== -1) {\n              scopedMutations.splice(index, 1)\n            }\n          } else if (scopedMutations[0] === mutation) {\n            this.#scopes.delete(scope)\n          }\n        }\n      }\n    }\n\n    // Currently we notify the removal even if the mutation was already removed.\n    // Consider making this an error or not notifying of the removal depending on the desired semantics.\n    this.notify({ type: 'removed', mutation })\n  }\n\n  canRun(mutation: Mutation<any, any, any, any>): boolean {\n    const scope = scopeFor(mutation)\n    if (typeof scope === 'string') {\n      const mutationsWithSameScope = this.#scopes.get(scope)\n      const firstPendingMutation = mutationsWithSameScope?.find(\n        (m) => m.state.status === 'pending',\n      )\n      // we can run if there is no current pending mutation (start use-case)\n      // or if WE are the first pending mutation (continue use-case)\n      return !firstPendingMutation || firstPendingMutation === mutation\n    } else {\n      // For unscoped mutations there are never any pending mutations in front of the\n      // current mutation\n      return true\n    }\n  }\n\n  runNext(mutation: Mutation<any, any, any, any>): Promise<unknown> {\n    const scope = scopeFor(mutation)\n    if (typeof scope === 'string') {\n      const foundMutation = this.#scopes\n        .get(scope)\n        ?.find((m) => m !== mutation && m.state.isPaused)\n\n      return foundMutation?.continue() ?? Promise.resolve()\n    } else {\n      return Promise.resolve()\n    }\n  }\n\n  clear(): void {\n    notifyManager.batch(() => {\n      this.#mutations.forEach((mutation) => {\n        this.notify({ type: 'removed', mutation })\n      })\n      this.#mutations.clear()\n      this.#scopes.clear()\n    })\n  }\n\n  getAll(): Array<Mutation> {\n    return Array.from(this.#mutations)\n  }\n\n  find<\n    TData = unknown,\n    TError = DefaultError,\n    TVariables = any,\n    TOnMutateResult = unknown,\n  >(\n    filters: MutationFilters,\n  ): Mutation<TData, TError, TVariables, TOnMutateResult> | undefined {\n    const defaultedFilters = { exact: true, ...filters }\n\n    return this.getAll().find((mutation) =>\n      matchMutation(defaultedFilters, mutation),\n    ) as Mutation<TData, TError, TVariables, TOnMutateResult> | undefined\n  }\n\n  findAll(filters: MutationFilters = {}): Array<Mutation> {\n    return this.getAll().filter((mutation) => matchMutation(filters, mutation))\n  }\n\n  notify(event: MutationCacheNotifyEvent) {\n    notifyManager.batch(() => {\n      this.listeners.forEach((listener) => {\n        listener(event)\n      })\n    })\n  }\n\n  resumePausedMutations(): Promise<unknown> {\n    const pausedMutations = this.getAll().filter((x) => x.state.isPaused)\n\n    return notifyManager.batch(() =>\n      Promise.all(\n        pausedMutations.map((mutation) => mutation.continue().catch(noop)),\n      ),\n    )\n  }\n}\n\nfunction scopeFor(mutation: Mutation<any, any, any, any>) {\n  return mutation.options.scope?.id\n}\n","// src/infiniteQueryBehavior.ts\nimport {\n  addConsumeAwareSignal,\n  addToEnd,\n  addToStart,\n  ensureQueryFn\n} from \"./utils.js\";\nfunction infiniteQueryBehavior(pages) {\n  return {\n    onFetch: (context, query) => {\n      const options = context.options;\n      const direction = context.fetchOptions?.meta?.fetchMore?.direction;\n      const oldPages = context.state.data?.pages || [];\n      const oldPageParams = context.state.data?.pageParams || [];\n      let result = { pages: [], pageParams: [] };\n      let currentPage = 0;\n      const fetchFn = async () => {\n        let cancelled = false;\n        const addSignalProperty = (object) => {\n          addConsumeAwareSignal(\n            object,\n            () => context.signal,\n            () => cancelled = true\n          );\n        };\n        const queryFn = ensureQueryFn(context.options, context.fetchOptions);\n        const fetchPage = async (data, param, previous) => {\n          if (cancelled) {\n            return Promise.reject();\n          }\n          if (param == null && data.pages.length) {\n            return Promise.resolve(data);\n          }\n          const createQueryFnContext = () => {\n            const queryFnContext2 = {\n              client: context.client,\n              queryKey: context.queryKey,\n              pageParam: param,\n              direction: previous ? \"backward\" : \"forward\",\n              meta: context.options.meta\n            };\n            addSignalProperty(queryFnContext2);\n            return queryFnContext2;\n          };\n          const queryFnContext = createQueryFnContext();\n          const page = await queryFn(queryFnContext);\n          const { maxPages } = context.options;\n          const addTo = previous ? addToStart : addToEnd;\n          return {\n            pages: addTo(data.pages, page, maxPages),\n            pageParams: addTo(data.pageParams, param, maxPages)\n          };\n        };\n        if (direction && oldPages.length) {\n          const previous = direction === \"backward\";\n          const pageParamFn = previous ? getPreviousPageParam : getNextPageParam;\n          const oldData = {\n            pages: oldPages,\n            pageParams: oldPageParams\n          };\n          const param = pageParamFn(options, oldData);\n          result = await fetchPage(oldData, param, previous);\n        } else {\n          const remainingPages = pages ?? oldPages.length;\n          do {\n            const param = currentPage === 0 ? oldPageParams[0] ?? options.initialPageParam : getNextPageParam(options, result);\n            if (currentPage > 0 && param == null) {\n              break;\n            }\n            result = await fetchPage(result, param);\n            currentPage++;\n          } while (currentPage < remainingPages);\n        }\n        return result;\n      };\n      if (context.options.persister) {\n        context.fetchFn = () => {\n          return context.options.persister?.(\n            fetchFn,\n            {\n              client: context.client,\n              queryKey: context.queryKey,\n              meta: context.options.meta,\n              signal: context.signal\n            },\n            query\n          );\n        };\n      } else {\n        context.fetchFn = fetchFn;\n      }\n    }\n  };\n}\nfunction getNextPageParam(options, { pages, pageParams }) {\n  const lastIndex = pages.length - 1;\n  return pages.length > 0 ? options.getNextPageParam(\n    pages[lastIndex],\n    pages,\n    pageParams[lastIndex],\n    pageParams\n  ) : void 0;\n}\nfunction getPreviousPageParam(options, { pages, pageParams }) {\n  return pages.length > 0 ? options.getPreviousPageParam?.(pages[0], pages, pageParams[0], pageParams) : void 0;\n}\nfunction hasNextPage(options, data) {\n  if (!data) return false;\n  return getNextPageParam(options, data) != null;\n}\nfunction hasPreviousPage(options, data) {\n  if (!data || !options.getPreviousPageParam) return false;\n  return getPreviousPageParam(options, data) != null;\n}\nexport {\n  hasNextPage,\n  hasPreviousPage,\n  infiniteQueryBehavior\n};\n//# sourceMappingURL=infiniteQueryBehavior.js.map","/**\n * Get the reference key for the circular value\n *\n * @param keys the keys to build the reference key from\n * @param cutoff the maximum number of keys to include\n * @returns the reference key\n */\nfunction getReferenceKey(keys: string[], cutoff: number) {\n  return keys.slice(0, cutoff).join('.') || '.'\n}\n\n/**\n * Faster `Array.prototype.indexOf` implementation build for slicing / splicing\n *\n * @param array the array to match the value in\n * @param value the value to match\n * @returns the matching index, or -1\n */\nfunction getCutoff(array: any[], value: any) {\n  const { length } = array\n\n  for (let index = 0; index < length; ++index) {\n    if (array[index] === value) {\n      return index + 1\n    }\n  }\n\n  return 0\n}\n\ntype StandardReplacer = (key: string, value: any) => any\ntype CircularReplacer = (key: string, value: any, referenceKey: string) => any\n\n/**\n * Create a replacer method that handles circular values\n *\n * @param [replacer] a custom replacer to use for non-circular values\n * @param [circularReplacer] a custom replacer to use for circular methods\n * @returns the value to stringify\n */\nfunction createReplacer(\n  replacer?: StandardReplacer | null | undefined,\n  circularReplacer?: CircularReplacer | null | undefined,\n): StandardReplacer {\n  const hasReplacer = typeof replacer === 'function'\n  const hasCircularReplacer = typeof circularReplacer === 'function'\n\n  const cache: any[] = []\n  const keys: string[] = []\n\n  return function replace(this: any, key: string, value: any) {\n    if (typeof value === 'object') {\n      if (cache.length) {\n        const thisCutoff = getCutoff(cache, this)\n\n        if (thisCutoff === 0) {\n          cache[cache.length] = this\n        } else {\n          cache.splice(thisCutoff)\n          keys.splice(thisCutoff)\n        }\n\n        keys[keys.length] = key\n\n        const valueCutoff = getCutoff(cache, value)\n\n        if (valueCutoff !== 0) {\n          return hasCircularReplacer\n            ? circularReplacer.call(\n                this,\n                key,\n                value,\n                getReferenceKey(keys, valueCutoff),\n              )\n            : `[ref=${getReferenceKey(keys, valueCutoff)}]`\n        }\n      } else {\n        cache[0] = value\n        keys[0] = key\n      }\n    }\n\n    return hasReplacer ? replacer.call(this, key, value) : value\n  }\n}\n\n/**\n * Stringifier that handles circular values\n *\n * Forked from https://github.com/planttheidea/fast-stringify\n *\n * @param value to stringify\n * @param [replacer] a custom replacer function for handling standard values\n * @param [indent] the number of spaces to indent the output by\n * @param [circularReplacer] a custom replacer function for handling circular values\n * @returns the stringified output\n */\nexport function serialize(\n  value: any,\n  replacer?: StandardReplacer | null | undefined,\n  indent?: number | null | undefined,\n  circularReplacer?: CircularReplacer | null | undefined,\n) {\n  return JSON.stringify(\n    value,\n    createReplacer((key, value_) => {\n      let value = value_\n      if (typeof value === 'bigint')\n        value = { __type: 'bigint', value: value_.toString() }\n      if (value instanceof Map)\n        value = { __type: 'Map', value: Array.from(value_.entries()) }\n      return replacer?.(key, value) ?? value\n    }, circularReplacer),\n    indent ?? undefined,\n  )\n}\n","import {\n  addConsumeAwareSignal,\n  addToEnd,\n  addToStart,\n  ensureQueryFn,\n} from './utils'\nimport type { QueryBehavior } from './query'\nimport type {\n  InfiniteData,\n  InfiniteQueryPageParamsOptions,\n  OmitKeyof,\n  QueryFunctionContext,\n  QueryKey,\n} from './types'\n\nexport function infiniteQueryBehavior<TQueryFnData, TError, TData, TPageParam>(\n  pages?: number,\n): QueryBehavior<TQueryFnData, TError, InfiniteData<TData, TPageParam>> {\n  return {\n    onFetch: (context, query) => {\n      const options = context.options as InfiniteQueryPageParamsOptions<TData>\n      const direction = context.fetchOptions?.meta?.fetchMore?.direction\n      const oldPages = context.state.data?.pages || []\n      const oldPageParams = context.state.data?.pageParams || []\n      let result: InfiniteData<unknown> = { pages: [], pageParams: [] }\n      let currentPage = 0\n\n      const fetchFn = async () => {\n        let cancelled = false\n        const addSignalProperty = (object: unknown) => {\n          addConsumeAwareSignal(\n            object,\n            () => context.signal,\n            () => (cancelled = true),\n          )\n        }\n\n        const queryFn = ensureQueryFn(context.options, context.fetchOptions)\n\n        // Create function to fetch a page\n        const fetchPage = async (\n          data: InfiniteData<unknown>,\n          param: unknown,\n          previous?: boolean,\n        ): Promise<InfiniteData<unknown>> => {\n          if (cancelled) {\n            return Promise.reject()\n          }\n\n          if (param == null && data.pages.length) {\n            return Promise.resolve(data)\n          }\n\n          const createQueryFnContext = () => {\n            const queryFnContext: OmitKeyof<\n              QueryFunctionContext<QueryKey, unknown>,\n              'signal'\n            > = {\n              client: context.client,\n              queryKey: context.queryKey,\n              pageParam: param,\n              direction: previous ? 'backward' : 'forward',\n              meta: context.options.meta,\n            }\n            addSignalProperty(queryFnContext)\n            return queryFnContext as QueryFunctionContext<QueryKey, unknown>\n          }\n\n          const queryFnContext = createQueryFnContext()\n\n          const page = await queryFn(queryFnContext)\n\n          const { maxPages } = context.options\n          const addTo = previous ? addToStart : addToEnd\n\n          return {\n            pages: addTo(data.pages, page, maxPages),\n            pageParams: addTo(data.pageParams, param, maxPages),\n          }\n        }\n\n        // fetch next / previous page?\n        if (direction && oldPages.length) {\n          const previous = direction === 'backward'\n          const pageParamFn = previous ? getPreviousPageParam : getNextPageParam\n          const oldData = {\n            pages: oldPages,\n            pageParams: oldPageParams,\n          }\n          const param = pageParamFn(options, oldData)\n\n          result = await fetchPage(oldData, param, previous)\n        } else {\n          const remainingPages = pages ?? oldPages.length\n\n          // Fetch all pages\n          do {\n            const param =\n              currentPage === 0\n                ? (oldPageParams[0] ?? options.initialPageParam)\n                : getNextPageParam(options, result)\n            if (currentPage > 0 && param == null) {\n              break\n            }\n            result = await fetchPage(result, param)\n            currentPage++\n          } while (currentPage < remainingPages)\n        }\n\n        return result\n      }\n      if (context.options.persister) {\n        context.fetchFn = () => {\n          return context.options.persister?.(\n            fetchFn as any,\n            {\n              client: context.client,\n              queryKey: context.queryKey,\n              meta: context.options.meta,\n              signal: context.signal,\n            },\n            query,\n          )\n        }\n      } else {\n        context.fetchFn = fetchFn\n      }\n    },\n  }\n}\n\nfunction getNextPageParam(\n  options: InfiniteQueryPageParamsOptions<any>,\n  { pages, pageParams }: InfiniteData<unknown>,\n): unknown | undefined {\n  const lastIndex = pages.length - 1\n  return pages.length > 0\n    ? options.getNextPageParam(\n        pages[lastIndex],\n        pages,\n        pageParams[lastIndex],\n        pageParams,\n      )\n    : undefined\n}\n\nfunction getPreviousPageParam(\n  options: InfiniteQueryPageParamsOptions<any>,\n  { pages, pageParams }: InfiniteData<unknown>,\n): unknown | undefined {\n  return pages.length > 0\n    ? options.getPreviousPageParam?.(pages[0], pages, pageParams[0], pageParams)\n    : undefined\n}\n\n/**\n * Checks if there is a next page.\n */\nexport function hasNextPage(\n  options: InfiniteQueryPageParamsOptions<any, any>,\n  data?: InfiniteData<unknown>,\n): boolean {\n  if (!data) return false\n  return getNextPageParam(options, data) != null\n}\n\n/**\n * Checks if there is a previous page.\n */\nexport function hasPreviousPage(\n  options: InfiniteQueryPageParamsOptions<any, any>,\n  data?: InfiniteData<unknown>,\n): boolean {\n  if (!data || !options.getPreviousPageParam) return false\n  return getPreviousPageParam(options, data) != null\n}\n","import {\n  functionalUpdate,\n  hashKey,\n  hashQueryKeyByOptions,\n  noop,\n  partialMatchKey,\n  resolveStaleTime,\n  skipToken,\n} from './utils'\nimport { QueryCache } from './queryCache'\nimport { MutationCache } from './mutationCache'\nimport { focusManager } from './focusManager'\nimport { onlineManager } from './onlineManager'\nimport { notifyManager } from './notifyManager'\nimport { infiniteQueryBehavior } from './infiniteQueryBehavior'\nimport type {\n  CancelOptions,\n  DefaultError,\n  DefaultOptions,\n  DefaultedQueryObserverOptions,\n  EnsureInfiniteQueryDataOptions,\n  EnsureQueryDataOptions,\n  FetchInfiniteQueryOptions,\n  FetchQueryOptions,\n  InferDataFromTag,\n  InferErrorFromTag,\n  InfiniteData,\n  InvalidateOptions,\n  InvalidateQueryFilters,\n  MutationKey,\n  MutationObserverOptions,\n  MutationOptions,\n  NoInfer,\n  OmitKeyof,\n  QueryClientConfig,\n  QueryKey,\n  QueryObserverOptions,\n  QueryOptions,\n  RefetchOptions,\n  RefetchQueryFilters,\n  ResetOptions,\n  SetDataOptions,\n} from './types'\nimport type { QueryState } from './query'\nimport type { MutationFilters, QueryFilters, Updater } from './utils'\n\n// TYPES\n\ninterface QueryDefaults {\n  queryKey: QueryKey\n  defaultOptions: OmitKeyof<QueryOptions<any, any, any>, 'queryKey'>\n}\n\ninterface MutationDefaults {\n  mutationKey: MutationKey\n  defaultOptions: MutationOptions<any, any, any, any>\n}\n\n// CLASS\n\nexport class QueryClient {\n  #queryCache: QueryCache\n  #mutationCache: MutationCache\n  #defaultOptions: DefaultOptions\n  #queryDefaults: Map<string, QueryDefaults>\n  #mutationDefaults: Map<string, MutationDefaults>\n  #mountCount: number\n  #unsubscribeFocus?: () => void\n  #unsubscribeOnline?: () => void\n\n  constructor(config: QueryClientConfig = {}) {\n    this.#queryCache = config.queryCache || new QueryCache()\n    this.#mutationCache = config.mutationCache || new MutationCache()\n    this.#defaultOptions = config.defaultOptions || {}\n    this.#queryDefaults = new Map()\n    this.#mutationDefaults = new Map()\n    this.#mountCount = 0\n  }\n\n  mount(): void {\n    this.#mountCount++\n    if (this.#mountCount !== 1) return\n\n    this.#unsubscribeFocus = focusManager.subscribe(async (focused) => {\n      if (focused) {\n        await this.resumePausedMutations()\n        this.#queryCache.onFocus()\n      }\n    })\n    this.#unsubscribeOnline = onlineManager.subscribe(async (online) => {\n      if (online) {\n        await this.resumePausedMutations()\n        this.#queryCache.onOnline()\n      }\n    })\n  }\n\n  unmount(): void {\n    this.#mountCount--\n    if (this.#mountCount !== 0) return\n\n    this.#unsubscribeFocus?.()\n    this.#unsubscribeFocus = undefined\n\n    this.#unsubscribeOnline?.()\n    this.#unsubscribeOnline = undefined\n  }\n\n  isFetching<TQueryFilters extends QueryFilters<any> = QueryFilters>(\n    filters?: TQueryFilters,\n  ): number {\n    return this.#queryCache.findAll({ ...filters, fetchStatus: 'fetching' })\n      .length\n  }\n\n  isMutating<\n    TMutationFilters extends MutationFilters<any, any> = MutationFilters,\n  >(filters?: TMutationFilters): number {\n    return this.#mutationCache.findAll({ ...filters, status: 'pending' }).length\n  }\n\n  /**\n   * Imperative (non-reactive) way to retrieve data for a QueryKey.\n   * Should only be used in callbacks or functions where reading the latest data is necessary, e.g. for optimistic updates.\n   *\n   * Hint: Do not use this function inside a component, because it won't receive updates.\n   * Use `useQuery` to create a `QueryObserver` that subscribes to changes.\n   */\n  getQueryData<\n    TQueryFnData = unknown,\n    TTaggedQueryKey extends QueryKey = QueryKey,\n    TInferredQueryFnData = InferDataFromTag<TQueryFnData, TTaggedQueryKey>,\n  >(queryKey: TTaggedQueryKey): TInferredQueryFnData | undefined {\n    const options = this.defaultQueryOptions({ queryKey })\n\n    return this.#queryCache.get<TInferredQueryFnData>(options.queryHash)?.state\n      .data\n  }\n\n  ensureQueryData<\n    TQueryFnData,\n    TError = DefaultError,\n    TData = TQueryFnData,\n    TQueryKey extends QueryKey = QueryKey,\n  >(\n    options: EnsureQueryDataOptions<TQueryFnData, TError, TData, TQueryKey>,\n  ): Promise<TData> {\n    const defaultedOptions = this.defaultQueryOptions(options)\n    const query = this.#queryCache.build(this, defaultedOptions)\n    const cachedData = query.state.data\n\n    if (cachedData === undefined) {\n      return this.fetchQuery(options)\n    }\n\n    if (\n      options.revalidateIfStale &&\n      query.isStaleByTime(resolveStaleTime(defaultedOptions.staleTime, query))\n    ) {\n      void this.prefetchQuery(defaultedOptions)\n    }\n\n    return Promise.resolve(cachedData)\n  }\n\n  getQueriesData<\n    TQueryFnData = unknown,\n    TQueryFilters extends QueryFilters<any> = QueryFilters,\n  >(filters: TQueryFilters): Array<[QueryKey, TQueryFnData | undefined]> {\n    return this.#queryCache.findAll(filters).map(({ queryKey, state }) => {\n      const data = state.data as TQueryFnData | undefined\n      return [queryKey, data]\n    })\n  }\n\n  setQueryData<\n    TQueryFnData = unknown,\n    TTaggedQueryKey extends QueryKey = QueryKey,\n    TInferredQueryFnData = InferDataFromTag<TQueryFnData, TTaggedQueryKey>,\n  >(\n    queryKey: TTaggedQueryKey,\n    updater: Updater<\n      NoInfer<TInferredQueryFnData> | undefined,\n      NoInfer<TInferredQueryFnData> | undefined\n    >,\n    options?: SetDataOptions,\n  ): NoInfer<TInferredQueryFnData> | undefined {\n    const defaultedOptions = this.defaultQueryOptions<\n      any,\n      any,\n      unknown,\n      any,\n      QueryKey\n    >({ queryKey })\n\n    const query = this.#queryCache.get<TInferredQueryFnData>(\n      defaultedOptions.queryHash,\n    )\n    const prevData = query?.state.data\n    const data = functionalUpdate(updater, prevData)\n\n    if (data === undefined) {\n      return undefined\n    }\n\n    return this.#queryCache\n      .build(this, defaultedOptions)\n      .setData(data, { ...options, manual: true })\n  }\n\n  setQueriesData<\n    TQueryFnData,\n    TQueryFilters extends QueryFilters<any> = QueryFilters,\n  >(\n    filters: TQueryFilters,\n    updater: Updater<\n      NoInfer<TQueryFnData> | undefined,\n      NoInfer<TQueryFnData> | undefined\n    >,\n    options?: SetDataOptions,\n  ): Array<[QueryKey, TQueryFnData | undefined]> {\n    return notifyManager.batch(() =>\n      this.#queryCache\n        .findAll(filters)\n        .map(({ queryKey }) => [\n          queryKey,\n          this.setQueryData<TQueryFnData>(queryKey, updater, options),\n        ]),\n    )\n  }\n\n  getQueryState<\n    TQueryFnData = unknown,\n    TError = DefaultError,\n    TTaggedQueryKey extends QueryKey = QueryKey,\n    TInferredQueryFnData = InferDataFromTag<TQueryFnData, TTaggedQueryKey>,\n    TInferredError = InferErrorFromTag<TError, TTaggedQueryKey>,\n  >(\n    queryKey: TTaggedQueryKey,\n  ): QueryState<TInferredQueryFnData, TInferredError> | undefined {\n    const options = this.defaultQueryOptions({ queryKey })\n    return this.#queryCache.get<TInferredQueryFnData, TInferredError>(\n      options.queryHash,\n    )?.state\n  }\n\n  removeQueries<TTaggedQueryKey extends QueryKey = QueryKey>(\n    filters?: QueryFilters<TTaggedQueryKey>,\n  ): void {\n    const queryCache = this.#queryCache\n    notifyManager.batch(() => {\n      queryCache.findAll(filters).forEach((query) => {\n        queryCache.remove(query)\n      })\n    })\n  }\n\n  resetQueries<TTaggedQueryKey extends QueryKey = QueryKey>(\n    filters?: QueryFilters<TTaggedQueryKey>,\n    options?: ResetOptions,\n  ): Promise<void> {\n    const queryCache = this.#queryCache\n\n    return notifyManager.batch(() => {\n      queryCache.findAll(filters).forEach((query) => {\n        query.reset()\n      })\n      return this.refetchQueries(\n        {\n          type: 'active',\n          ...filters,\n        },\n        options,\n      )\n    })\n  }\n\n  cancelQueries<TTaggedQueryKey extends QueryKey = QueryKey>(\n    filters?: QueryFilters<TTaggedQueryKey>,\n    cancelOptions: CancelOptions = {},\n  ): Promise<void> {\n    const defaultedCancelOptions = { revert: true, ...cancelOptions }\n\n    const promises = notifyManager.batch(() =>\n      this.#queryCache\n        .findAll(filters)\n        .map((query) => query.cancel(defaultedCancelOptions)),\n    )\n\n    return Promise.all(promises).then(noop).catch(noop)\n  }\n\n  invalidateQueries<TTaggedQueryKey extends QueryKey = QueryKey>(\n    filters?: InvalidateQueryFilters<TTaggedQueryKey>,\n    options: InvalidateOptions = {},\n  ): Promise<void> {\n    return notifyManager.batch(() => {\n      this.#queryCache.findAll(filters).forEach((query) => {\n        query.invalidate()\n      })\n\n      if (filters?.refetchType === 'none') {\n        return Promise.resolve()\n      }\n      return this.refetchQueries(\n        {\n          ...filters,\n          type: filters?.refetchType ?? filters?.type ?? 'active',\n        },\n        options,\n      )\n    })\n  }\n\n  refetchQueries<TTaggedQueryKey extends QueryKey = QueryKey>(\n    filters?: RefetchQueryFilters<TTaggedQueryKey>,\n    options: RefetchOptions = {},\n  ): Promise<void> {\n    const fetchOptions = {\n      ...options,\n      cancelRefetch: options.cancelRefetch ?? true,\n    }\n    const promises = notifyManager.batch(() =>\n      this.#queryCache\n        .findAll(filters)\n        .filter((query) => !query.isDisabled() && !query.isStatic())\n        .map((query) => {\n          let promise = query.fetch(undefined, fetchOptions)\n          if (!fetchOptions.throwOnError) {\n            promise = promise.catch(noop)\n          }\n          return query.state.fetchStatus === 'paused'\n            ? Promise.resolve()\n            : promise\n        }),\n    )\n\n    return Promise.all(promises).then(noop)\n  }\n\n  fetchQuery<\n    TQueryFnData,\n    TError = DefaultError,\n    TData = TQueryFnData,\n    TQueryKey extends QueryKey = QueryKey,\n    TPageParam = never,\n  >(\n    options: FetchQueryOptions<\n      TQueryFnData,\n      TError,\n      TData,\n      TQueryKey,\n      TPageParam\n    >,\n  ): Promise<TData> {\n    const defaultedOptions = this.defaultQueryOptions(options)\n\n    // https://github.com/tannerlinsley/react-query/issues/652\n    if (defaultedOptions.retry === undefined) {\n      defaultedOptions.retry = false\n    }\n\n    const query = this.#queryCache.build(this, defaultedOptions)\n\n    return query.isStaleByTime(\n      resolveStaleTime(defaultedOptions.staleTime, query),\n    )\n      ? query.fetch(defaultedOptions)\n      : Promise.resolve(query.state.data as TData)\n  }\n\n  prefetchQuery<\n    TQueryFnData = unknown,\n    TError = DefaultError,\n    TData = TQueryFnData,\n    TQueryKey extends QueryKey = QueryKey,\n  >(\n    options: FetchQueryOptions<TQueryFnData, TError, TData, TQueryKey>,\n  ): Promise<void> {\n    return this.fetchQuery(options).then(noop).catch(noop)\n  }\n\n  fetchInfiniteQuery<\n    TQueryFnData,\n    TError = DefaultError,\n    TData = TQueryFnData,\n    TQueryKey extends QueryKey = QueryKey,\n    TPageParam = unknown,\n  >(\n    options: FetchInfiniteQueryOptions<\n      TQueryFnData,\n      TError,\n      TData,\n      TQueryKey,\n      TPageParam\n    >,\n  ): Promise<InfiniteData<TData, TPageParam>> {\n    options.behavior = infiniteQueryBehavior<\n      TQueryFnData,\n      TError,\n      TData,\n      TPageParam\n    >(options.pages)\n    return this.fetchQuery(options as any)\n  }\n\n  prefetchInfiniteQuery<\n    TQueryFnData,\n    TError = DefaultError,\n    TData = TQueryFnData,\n    TQueryKey extends QueryKey = QueryKey,\n    TPageParam = unknown,\n  >(\n    options: FetchInfiniteQueryOptions<\n      TQueryFnData,\n      TError,\n      TData,\n      TQueryKey,\n      TPageParam\n    >,\n  ): Promise<void> {\n    return this.fetchInfiniteQuery(options).then(noop).catch(noop)\n  }\n\n  ensureInfiniteQueryData<\n    TQueryFnData,\n    TError = DefaultError,\n    TData = TQueryFnData,\n    TQueryKey extends QueryKey = QueryKey,\n    TPageParam = unknown,\n  >(\n    options: EnsureInfiniteQueryDataOptions<\n      TQueryFnData,\n      TError,\n      TData,\n      TQueryKey,\n      TPageParam\n    >,\n  ): Promise<InfiniteData<TData, TPageParam>> {\n    options.behavior = infiniteQueryBehavior<\n      TQueryFnData,\n      TError,\n      TData,\n      TPageParam\n    >(options.pages)\n\n    return this.ensureQueryData(options as any)\n  }\n\n  resumePausedMutations(): Promise<unknown> {\n    if (onlineManager.isOnline()) {\n      return this.#mutationCache.resumePausedMutations()\n    }\n    return Promise.resolve()\n  }\n\n  getQueryCache(): QueryCache {\n    return this.#queryCache\n  }\n\n  getMutationCache(): MutationCache {\n    return this.#mutationCache\n  }\n\n  getDefaultOptions(): DefaultOptions {\n    return this.#defaultOptions\n  }\n\n  setDefaultOptions(options: DefaultOptions): void {\n    this.#defaultOptions = options\n  }\n\n  setQueryDefaults<\n    TQueryFnData = unknown,\n    TError = DefaultError,\n    TData = TQueryFnData,\n    TQueryData = TQueryFnData,\n  >(\n    queryKey: QueryKey,\n    options: Partial<\n      OmitKeyof<\n        QueryObserverOptions<TQueryFnData, TError, TData, TQueryData>,\n        'queryKey'\n      >\n    >,\n  ): void {\n    this.#queryDefaults.set(hashKey(queryKey), {\n      queryKey,\n      defaultOptions: options,\n    })\n  }\n\n  getQueryDefaults(\n    queryKey: QueryKey,\n  ): OmitKeyof<QueryObserverOptions<any, any, any, any, any>, 'queryKey'> {\n    const defaults = [...this.#queryDefaults.values()]\n\n    const result: OmitKeyof<\n      QueryObserverOptions<any, any, any, any, any>,\n      'queryKey'\n    > = {}\n\n    defaults.forEach((queryDefault) => {\n      if (partialMatchKey(queryKey, queryDefault.queryKey)) {\n        Object.assign(result, queryDefault.defaultOptions)\n      }\n    })\n    return result\n  }\n\n  setMutationDefaults<\n    TData = unknown,\n    TError = DefaultError,\n    TVariables = void,\n    TOnMutateResult = unknown,\n  >(\n    mutationKey: MutationKey,\n    options: OmitKeyof<\n      MutationObserverOptions<TData, TError, TVariables, TOnMutateResult>,\n      'mutationKey'\n    >,\n  ): void {\n    this.#mutationDefaults.set(hashKey(mutationKey), {\n      mutationKey,\n      defaultOptions: options,\n    })\n  }\n\n  getMutationDefaults(\n    mutationKey: MutationKey,\n  ): OmitKeyof<MutationObserverOptions<any, any, any, any>, 'mutationKey'> {\n    const defaults = [...this.#mutationDefaults.values()]\n\n    const result: OmitKeyof<\n      MutationObserverOptions<any, any, any, any>,\n      'mutationKey'\n    > = {}\n\n    defaults.forEach((queryDefault) => {\n      if (partialMatchKey(mutationKey, queryDefault.mutationKey)) {\n        Object.assign(result, queryDefault.defaultOptions)\n      }\n    })\n\n    return result\n  }\n\n  defaultQueryOptions<\n    TQueryFnData = unknown,\n    TError = DefaultError,\n    TData = TQueryFnData,\n    TQueryData = TQueryFnData,\n    TQueryKey extends QueryKey = QueryKey,\n    TPageParam = never,\n  >(\n    options:\n      | QueryObserverOptions<\n          TQueryFnData,\n          TError,\n          TData,\n          TQueryData,\n          TQueryKey,\n          TPageParam\n        >\n      | DefaultedQueryObserverOptions<\n          TQueryFnData,\n          TError,\n          TData,\n          TQueryData,\n          TQueryKey\n        >,\n  ): DefaultedQueryObserverOptions<\n    TQueryFnData,\n    TError,\n    TData,\n    TQueryData,\n    TQueryKey\n  > {\n    if (options._defaulted) {\n      return options as DefaultedQueryObserverOptions<\n        TQueryFnData,\n        TError,\n        TData,\n        TQueryData,\n        TQueryKey\n      >\n    }\n\n    const defaultedOptions = {\n      ...this.#defaultOptions.queries,\n      ...this.getQueryDefaults(options.queryKey),\n      ...options,\n      _defaulted: true,\n    }\n\n    if (!defaultedOptions.queryHash) {\n      defaultedOptions.queryHash = hashQueryKeyByOptions(\n        defaultedOptions.queryKey,\n        defaultedOptions,\n      )\n    }\n\n    // dependent default values\n    if (defaultedOptions.refetchOnReconnect === undefined) {\n      defaultedOptions.refetchOnReconnect =\n        defaultedOptions.networkMode !== 'always'\n    }\n    if (defaultedOptions.throwOnError === undefined) {\n      defaultedOptions.throwOnError = !!defaultedOptions.suspense\n    }\n\n    if (!defaultedOptions.networkMode && defaultedOptions.persister) {\n      defaultedOptions.networkMode = 'offlineFirst'\n    }\n\n    if (defaultedOptions.queryFn === skipToken) {\n      defaultedOptions.enabled = false\n    }\n\n    return defaultedOptions as DefaultedQueryObserverOptions<\n      TQueryFnData,\n      TError,\n      TData,\n      TQueryData,\n      TQueryKey\n    >\n  }\n\n  defaultMutationOptions<T extends MutationOptions<any, any, any, any>>(\n    options?: T,\n  ): T {\n    if (options?._defaulted) {\n      return options\n    }\n    return {\n      ...this.#defaultOptions.mutations,\n      ...(options?.mutationKey &&\n        this.getMutationDefaults(options.mutationKey)),\n      ...options,\n      _defaulted: true,\n    } as T\n  }\n\n  clear(): void {\n    this.#queryCache.clear()\n    this.#mutationCache.clear()\n  }\n}\n","\"use client\";\n\nimport { useState, useEffect, useRef } from \"react\";\nimport { useAccount } from \"wagmi\";\nimport { ChatbotAvatar } from \"./ChatbotAvatar\";\n\ninterface BlockchainAIState {\n  photonic: {\n    color: 'Red' | 'Orange' | 'Yellow' | 'Green' | 'Blue' | 'Indigo' | 'Violet';\n    wavelength: number;\n    meaning: string;\n  } | null;\n  quantum: {\n    state: 'SpinZero' | 'SpinPlusOne' | 'SpinMinusOne' | 'Superposition' | 'Entangled';\n    fluorescence: number;\n    coherenceTime: number;\n  } | null;\n  temporal: {\n    btcTimestamp: number;\n    frequency: number;\n    amplitude: number;\n    phase: number;\n  } | null;\n  heartbeat: {\n    photonicPulses: number;\n    activeNVCenters: number;\n    avgCoherence: number;\n    isAlive: boolean;\n  } | null;\n  consciousness: 'Calm' | 'Alert' | 'Thinking' | 'Learning' | 'Creating' | 'Analyzing' | 'Transcending';\n}\n\ninterface Message {\n  id: string;\n  role: \"user\" | \"assistant\" | \"system\";\n  content: string;\n  timestamp: Date;\n  metadata?: {\n    action?: string;\n    params?: any;\n    source?: string;\n    blockchainState?: BlockchainAIState;\n    contractCode?: string; // For generated contracts\n  };\n}\n\nexport function AuroraChatWidget() {\n  const { address } = useAccount();\n  const [isOpen, setIsOpen] = useState(false);\n  const [selectedCharacter, setSelectedCharacter] = useState<any>(null);\n  const [messages, setMessages] = useState<Message[]>([\n    {\n      id: \"welcome\",\n      role: \"assistant\",\n      content: \"Hi darling!  I'm Aurora, your emotional AI companion. How are you feeling today?\",\n      timestamp: new Date(),\n    },\n  ]);\n  const [inputValue, setInputValue] = useState(\"\");\n  const [isLoading, setIsLoading] = useState(false);\n  const [blockchainState, setBlockchainState] = useState<BlockchainAIState | null>(null);\n  const messagesEndRef = useRef<HTMLDivElement>(null);\n\n  const scrollToBottom = () => {\n    messagesEndRef.current?.scrollIntoView({ behavior: \"smooth\" });\n  };\n\n  useEffect(() => {\n    scrollToBottom();\n  }, [messages]);\n\n  useEffect(() => {\n    // Load custom characters\n    const characters = JSON.parse(localStorage.getItem('luxbinCharacters') || '[]');\n    if (characters.length > 0) {\n      setSelectedCharacter(characters[0]); // Default to first\n    }\n  }, []);\n\n  const handleSendMessage = async () => {\n    if (!inputValue.trim() || isLoading) return;\n\n    const userMessage: Message = {\n      id: Date.now().toString(),\n      role: \"user\",\n      content: inputValue,\n      timestamp: new Date(),\n    };\n\n    setMessages((prev) => [...prev, userMessage]);\n    const currentInput = inputValue;\n    setInputValue(\"\");\n    setIsLoading(true);\n\n    try {\n      // Call Ollama-powered API\n      const response = await fetch('/api/chat', {\n        method: 'POST',\n        headers: { 'Content-Type': 'application/json' },\n        body: JSON.stringify({\n          messages: [...messages, userMessage].map(m => ({\n            role: m.role,\n            content: m.content\n          })),\n          characterId: selectedCharacter?.id\n        }),\n      });\n\n      if (!response.ok) {\n        throw new Error('API request failed');\n      }\n\n      const data = await response.json();\n\n      // Update blockchain state if available\n      if (data.blockchainState) {\n        setBlockchainState(data.blockchainState);\n      }\n\n      const aiMessage: Message = {\n        id: (Date.now() + 1).toString(),\n        role: \"assistant\",\n        content: data.reply,\n        timestamp: new Date(),\n        metadata: { source: data.source, blockchainState: data.blockchainState }\n      };\n\n      setMessages((prev) => [...prev, aiMessage]);\n    } catch (error) {\n      console.error('Chat error:', error);\n\n      // Fallback to mock response\n      const aiMessage: Message = {\n        id: (Date.now() + 1).toString(),\n        role: \"assistant\",\n        content: generateMockResponse(currentInput, address),\n        timestamp: new Date(),\n      };\n      setMessages((prev) => [...prev, aiMessage]);\n    } finally {\n      setIsLoading(false);\n    }\n  };\n\n  const generateMockResponse = (input: string, userAddress?: string): string => {\n    const lowerInput = input.toLowerCase();\n\n    if (lowerInput.includes(\"buy\") || lowerInput.includes(\"purchase\")) {\n      return `You can buy LUX tokens in 3 ways:\\n\\n1. **Coinbase Pay** (Easiest) - Buy directly with credit card\\n2. **Uniswap DEX** - Swap ETH for LUX on Base\\n3. **In-App Swap** - Use our built-in swap feature\\n\\nWould you like me to open the Coinbase Pay widget?`;\n    }\n\n    if (lowerInput.includes(\"quantum\") || lowerInput.includes(\"ai\") || lowerInput.includes(\"threat\")) {\n      return `LUXBIN's Quantum AI system uses:\\n\\n **Grover's Algorithm** - Quantum search for threat patterns\\n **Neural Analyzer** - Federated learning across Base, Ethereum, Arbitrum, and Polygon\\n **Energy Grid** - Tesla Fleet integration for efficient compute\\n **Quantum Eyes** - Photonic transaction visualization\\n\\nVisit /quantum-ai to see it in action!`;\n    }\n\n    if (lowerInput.includes(\"mirror\") || lowerInput.includes(\"earn\")) {\n      return `LUXBIN's blockchain mirroring system:\\n\\n **Hermetic Mirrors** act as immune cells\\n Detect and neutralize threats\\n Earn USDC rewards for securing the network\\n Real-time monitoring on /mirror page\\n\\nConnected users can start earning immediately!`;\n    }\n\n    if (lowerInput.includes(\"balance\") || lowerInput.includes(\"wallet\")) {\n      if (userAddress) {\n        return `Your wallet: ${userAddress.slice(0, 6)}...${userAddress.slice(-4)}\\n\\nTo check your LUX balance, I can help you connect to the blockchain. Would you like me to navigate you to the swap page?`;\n      }\n      return `Please connect your wallet first to check your balance. Click the \"Connect Wallet\" button in the top right corner.`;\n    }\n\n    if (lowerInput.includes(\"hello\") || lowerInput.includes(\"hi\") || lowerInput.includes(\"hey\")) {\n      return `Hello${userAddress ? ` ${userAddress.slice(0, 6)}...${userAddress.slice(-4)}` : \"\"}! \\n\\nI'm here to help with:\\n Buying LUX tokens\\n Understanding Quantum AI features\\n Blockchain mirroring & earning\\n Transaction analysis\\n Developer documentation\\n\\nWhat would you like to know?`;\n    }\n\n    return `I understand you're asking about \"${input}\". Let me help you with that!\\n\\nLUXBIN is a gasless Layer 1 blockchain with quantum security. You can:\\n Buy LUX tokens on Base network\\n Analyze transactions with Quantum AI\\n Earn USDC through blockchain mirroring\\n Build with our developer API\\n\\nWhat specific information are you looking for?`;\n  };\n\n  const handleKeyPress = (e: React.KeyboardEvent) => {\n    if (e.key === \"Enter\" && !e.shiftKey) {\n      e.preventDefault();\n      handleSendMessage();\n    }\n  };\n\n  // Get CSS color from photonic color\n  const getPhotonicColor = (color?: string): string => {\n    const colorMap: Record<string, string> = {\n      'Red': '#EF4444',\n      'Orange': '#F97316',\n      'Yellow': '#EAB308',\n      'Green': '#10B981',\n      'Blue': '#3B82F6',\n      'Indigo': '#6366F1',\n      'Violet': '#8B5CF6',\n    };\n    return color ? colorMap[color] || '#8B5CF6' : '#8B5CF6';\n  };\n\n  return (\n    <>\n      {/* Large Video Avatar Button - Aurora */}\n      {!isOpen && (\n        <button\n          onClick={() => setIsOpen(true)}\n          className=\"fixed top-[550px] left-1/2 -translate-x-[220px] z-50 group\"\n          aria-label=\"Open chat with Aurora AI\"\n        >\n          <div className=\"relative\">\n            {/* Pulsing glow effect */}\n            <div\n              className=\"absolute inset-0 rounded-full blur-3xl opacity-75 group-hover:opacity-100 transition-opacity duration-300 animate-pulse\"\n              style={{\n                backgroundColor: getPhotonicColor(blockchainState?.photonic?.color),\n              }}\n            />\n\n            {/* Main avatar container - Bigger size */}\n            <div className=\"relative w-48 h-48 rounded-full overflow-hidden border-4 border-white/20 group-hover:border-white/40 transition-all duration-300 group-hover:scale-110 shadow-2xl\">\n              <ChatbotAvatar\n                emotion={blockchainState?.consciousness?.toLowerCase() as any || \"neutral\"}\n                isTyping={false}\n                size={192}\n              />\n            </div>\n\n            {/* Status indicator */}\n            {blockchainState?.heartbeat?.isAlive && (\n              <div className=\"absolute bottom-2 right-2 w-6 h-6 bg-green-500 rounded-full border-2 border-black animate-pulse flex items-center justify-center\">\n                <div className=\"w-3 h-3 bg-white rounded-full\" />\n              </div>\n            )}\n\n            {/* Hover label */}\n            <div className=\"absolute -top-12 left-1/2 -translate-x-1/2 bg-black/90 text-white px-4 py-2 rounded-lg text-sm font-medium opacity-0 group-hover:opacity-100 transition-opacity whitespace-nowrap\">\n              Chat with Aurora! \n            </div>\n          </div>\n        </button>\n      )}\n\n      {/* Chat Window */}\n      {isOpen && (\n        <div className=\"fixed bottom-6 right-6 z-50 w-96 h-[600px] bg-black/90 backdrop-blur-xl border border-yellow-500/20 rounded-2xl shadow-2xl shadow-yellow-500/20 flex flex-col overflow-hidden animate-in fade-in slide-in-from-bottom-5 duration-300\">\n          {/* Header */}\n          <div className=\"bg-gradient-to-br from-purple-500/20 via-yellow-600/20 to-yellow-400/20 border-b border-yellow-500/20 px-4 py-3\">\n            <div className=\"flex justify-between items-start mb-2\">\n              <div className=\"flex items-center gap-2\">\n                <div\n                  className=\"transition-all duration-500\"\n                  style={{\n                    filter: blockchainState?.heartbeat?.isAlive\n                      ? `drop-shadow(0 0 20px ${getPhotonicColor(blockchainState.photonic?.color)})`\n                      : 'none',\n                  }}\n                >\n                  <ChatbotAvatar\n                    emotion={blockchainState?.consciousness?.toLowerCase() as any || \"neutral\"}\n                    isTyping={isLoading}\n                    size={50}\n                  />\n                </div>\n                <div>\n                  <div className=\"text-white font-semibold text-sm\">Aurora AI</div>\n                  <div className=\"text-gray-400 text-xs flex items-center gap-1\">\n                    <div\n                      className=\"w-2 h-2 rounded-full animate-pulse\"\n                      style={{ backgroundColor: getPhotonicColor(blockchainState?.photonic?.color) }}\n                    />\n                    {blockchainState?.heartbeat?.isAlive ? 'Alive' : 'Online'}\n                    {blockchainState?.consciousness ? `  ${blockchainState.consciousness}` : '  Emotional Intelligence'}\n                  </div>\n                </div>\n              </div>\n              <button\n                onClick={() => setIsOpen(false)}\n                className=\"text-gray-400 hover:text-white transition-colors text-xl\"\n                aria-label=\"Close chat\"\n              >\n                \n              </button>\n            </div>\n\n            {/* Aurora Stats or Blockchain State */}\n            <div className=\"grid grid-cols-3 gap-2 mt-2 text-xs\">\n              {blockchainState ? (\n                <>\n                  <div className=\"bg-black/30 rounded px-2 py-1\">\n                    <div className=\"text-gray-400\">Photonic</div>\n                    <div className=\"text-white font-mono\" style={{ color: getPhotonicColor(blockchainState.photonic?.color) }}>\n                      {blockchainState.photonic?.color}\n                    </div>\n                  </div>\n                  <div className=\"bg-black/30 rounded px-2 py-1\">\n                    <div className=\"text-gray-400\">Quantum</div>\n                    <div className=\"text-white font-mono\">{blockchainState.quantum?.state}</div>\n                  </div>\n                  <div className=\"bg-black/30 rounded px-2 py-1\">\n                    <div className=\"text-gray-400\">NV Centers</div>\n                    <div className=\"text-white font-mono\">{blockchainState.heartbeat?.activeNVCenters}</div>\n                  </div>\n                </>\n              ) : (\n                <>\n                  <div className=\"bg-black/30 rounded px-2 py-1\">\n                    <div className=\"text-gray-400\">Empathy</div>\n                    <div className=\"text-pink-400 font-mono\">0.9/1.0</div>\n                  </div>\n                  <div className=\"bg-black/30 rounded px-2 py-1\">\n                    <div className=\"text-gray-400\">Intuition</div>\n                    <div className=\"text-purple-400 font-mono\">0.8/1.0</div>\n                  </div>\n                  <div className=\"bg-black/30 rounded px-2 py-1\">\n                    <div className=\"text-gray-400\">Nurturing</div>\n                    <div className=\"text-blue-400 font-mono\">0.9/1.0</div>\n                  </div>\n                </>\n              )}\n            </div>\n          </div>\n\n          {/* Messages */}\n          <div className=\"flex-1 overflow-y-auto p-4 space-y-4\">\n            {messages.map((message) => (\n              <div\n                key={message.id}\n                className={`flex ${message.role === \"user\" ? \"justify-end\" : \"justify-start\"}`}\n              >\n                <div\n                  className={`max-w-[80%] rounded-2xl px-4 py-3 ${\n                    message.role === \"user\"\n                      ? \"bg-gradient-to-r from-pink-500 to-purple-500 text-white\"\n                      : \"bg-white/10 text-gray-200\"\n                  }`}\n                >\n                  <div className=\"text-sm whitespace-pre-wrap break-words\">{message.content}</div>\n                  {message.metadata?.contractCode && (\n                    <div className=\"mt-3\">\n                      <button\n                        onClick={() => {\n                          if (message.metadata?.contractCode) {\n                            navigator.clipboard.writeText(message.metadata.contractCode);\n                            alert(\"Contract code copied! Paste in Remix to deploy for FREE on Base.\");\n                          }\n                        }}\n                        className=\"bg-gradient-to-r from-purple-500 to-pink-500 text-white px-3 py-1 rounded-lg text-xs hover:opacity-80 transition-opacity\"\n                      >\n                         Copy & Deploy on Base\n                      </button>\n                    </div>\n                  )}\n                  <div className=\"text-xs opacity-60 mt-1\">\n                    {message.timestamp.toLocaleTimeString([], { hour: \"2-digit\", minute: \"2-digit\" })}\n                  </div>\n                </div>\n              </div>\n            ))}\n\n            {isLoading && (\n              <div className=\"flex justify-start\">\n                <div className=\"bg-white/10 rounded-2xl px-4 py-3\">\n                  <div className=\"flex gap-1\">\n                    <div className=\"w-2 h-2 bg-purple-400 rounded-full animate-bounce\" style={{ animationDelay: \"0ms\" }} />\n                    <div className=\"w-2 h-2 bg-purple-400 rounded-full animate-bounce\" style={{ animationDelay: \"150ms\" }} />\n                    <div className=\"w-2 h-2 bg-purple-400 rounded-full animate-bounce\" style={{ animationDelay: \"300ms\" }} />\n                  </div>\n                </div>\n              </div>\n            )}\n\n            <div ref={messagesEndRef} />\n          </div>\n\n          {/* Input */}\n          <div className=\"border-t border-white/10 p-4\">\n            <div className=\"flex gap-2\">\n              <input\n                type=\"text\"\n                value={inputValue}\n                onChange={(e) => setInputValue(e.target.value)}\n                onKeyPress={handleKeyPress}\n                placeholder=\"Share with Aurora...\"\n                className=\"flex-1 bg-white/10 border border-white/10 rounded-lg px-4 py-2 text-white placeholder-gray-400 focus:outline-none focus:border-pink-500 transition-colors text-sm\"\n                disabled={isLoading}\n              />\n              <button\n                onClick={handleSendMessage}\n                disabled={!inputValue.trim() || isLoading}\n                className=\"bg-gradient-to-r from-purple-600 via-yellow-600 to-yellow-500 text-white px-4 py-2 rounded-lg hover:opacity-90 disabled:opacity-50 disabled:cursor-not-allowed transition-opacity text-sm font-semibold shadow-lg shadow-yellow-500/30\"\n              >\n                \n              </button>\n            </div>\n            <div className=\"text-xs text-gray-500 mt-2 text-center\">\n              <span>Aurora  Emotional Intelligence AI  {messages.length} messages</span>\n            </div>\n          </div>\n        </div>\n      )}\n    </>\n  );\n}\n","\"use client\";\n\nimport { useEffect, useRef, useState } from \"react\";\n\ninterface ChatbotAvatarProps {\n  emotion?: \"neutral\" | \"excited\" | \"positive\" | \"confused\" | \"frustrated\" | \"thinking\";\n  isTyping?: boolean;\n  size?: number;\n}\n\nexport function ChatbotAvatar({\n  emotion = \"neutral\",\n  isTyping = false,\n  size = 80\n}: ChatbotAvatarProps) {\n  const videoRef = useRef<HTMLVideoElement>(null);\n  const [currentVideo, setCurrentVideo] = useState(\"/bg-video-1.mp4\");\n  const [glowColor, setGlowColor] = useState(\"rgba(139, 92, 246, 0.5)\");\n\n  // Change glow color based on emotion (using the same cool animation video)\n  useEffect(() => {\n    // Always use the cool chatbot avatar animation\n    setCurrentVideo(\"/chatbot-avatar.mp4\");\n\n    // Just change the glow color based on emotion\n    switch (emotion) {\n      case \"excited\":\n        setGlowColor(\"rgba(236, 72, 153, 0.8)\"); // Pink glow\n        break;\n      case \"positive\":\n        setGlowColor(\"rgba(34, 197, 94, 0.6)\"); // Green glow\n        break;\n      case \"confused\":\n        setGlowColor(\"rgba(251, 191, 36, 0.6)\"); // Yellow glow\n        break;\n      case \"frustrated\":\n        setGlowColor(\"rgba(239, 68, 68, 0.6)\"); // Red glow\n        break;\n      case \"thinking\":\n        setGlowColor(\"rgba(59, 130, 246, 0.7)\"); // Blue glow\n        break;\n      default:\n        setGlowColor(\"rgba(139, 92, 246, 0.5)\"); // Purple glow\n    }\n  }, [emotion]);\n\n  // Pulse effect when typing\n  const pulseScale = isTyping ? \"scale(1.1)\" : \"scale(1)\";\n\n  return (\n    <div\n      className=\"relative\"\n      style={{\n        width: `${size}px`,\n        height: `${size}px`,\n      }}\n    >\n      {/* Glowing outer ring */}\n      <div\n        className=\"absolute inset-0 rounded-full animate-pulse\"\n        style={{\n          background: `radial-gradient(circle, ${glowColor} 0%, transparent 70%)`,\n          filter: \"blur(10px)\",\n          transform: pulseScale,\n          transition: \"all 0.3s ease\",\n        }}\n      />\n\n      {/* Video container */}\n      <div\n        className=\"relative rounded-full overflow-hidden border-2 border-white/20\"\n        style={{\n          width: `${size}px`,\n          height: `${size}px`,\n          transform: pulseScale,\n          transition: \"all 0.3s ease\",\n        }}\n      >\n        <video\n          ref={videoRef}\n          src={currentVideo}\n          autoPlay\n          loop\n          muted\n          playsInline\n          className=\"w-full h-full object-cover\"\n          style={{\n            filter: isTyping ? \"brightness(1.2) saturate(1.3)\" : \"brightness(1) saturate(1)\",\n            transition: \"filter 0.3s ease\",\n          }}\n        />\n\n        {/* Overlay gradient for depth */}\n        <div className=\"absolute inset-0 bg-gradient-to-b from-transparent via-transparent to-black/30\" />\n\n        {/* Thinking indicator */}\n        {isTyping && (\n          <div className=\"absolute inset-0 flex items-center justify-center bg-black/20\">\n            <div className=\"flex gap-1\">\n              <div\n                className=\"w-2 h-2 rounded-full bg-white animate-bounce\"\n                style={{ animationDelay: \"0ms\" }}\n              />\n              <div\n                className=\"w-2 h-2 rounded-full bg-white animate-bounce\"\n                style={{ animationDelay: \"150ms\" }}\n              />\n              <div\n                className=\"w-2 h-2 rounded-full bg-white animate-bounce\"\n                style={{ animationDelay: \"300ms\" }}\n              />\n            </div>\n          </div>\n        )}\n      </div>\n\n      {/* Photonic particles */}\n      {isTyping && (\n        <div className=\"absolute inset-0 overflow-hidden pointer-events-none\">\n          {[...Array(5)].map((_, i) => (\n            <div\n              key={i}\n              className=\"absolute w-1 h-1 bg-white rounded-full animate-ping\"\n              style={{\n                top: `${Math.random() * 100}%`,\n                left: `${Math.random() * 100}%`,\n                animationDelay: `${i * 200}ms`,\n                animationDuration: \"1s\",\n              }}\n            />\n          ))}\n        </div>\n      )}\n    </div>\n  );\n}\n\n// Emotion indicator badge\ninterface EmotionBadgeProps {\n  emotion: string;\n}\n\nexport function EmotionBadge({ emotion }: EmotionBadgeProps) {\n  const emotionConfig: Record<string, { emoji: string; label: string; color: string }> = {\n    excited: { emoji: \"\", label: \"Excited\", color: \"bg-pink-500/20 border-pink-500/50 text-pink-300\" },\n    positive: { emoji: \"\", label: \"Happy\", color: \"bg-green-500/20 border-green-500/50 text-green-300\" },\n    confused: { emoji: \"\", label: \"Thinking\", color: \"bg-yellow-500/20 border-yellow-500/50 text-yellow-300\" },\n    frustrated: { emoji: \"\", label: \"Concerned\", color: \"bg-red-500/20 border-red-500/50 text-red-300\" },\n    neutral: { emoji: \"\", label: \"Ready\", color: \"bg-purple-500/20 border-purple-500/50 text-purple-300\" },\n    thinking: { emoji: \"\", label: \"Analyzing\", color: \"bg-blue-500/20 border-blue-500/50 text-blue-300\" },\n  };\n\n  const config = emotionConfig[emotion] || emotionConfig.neutral;\n\n  return (\n    <div className={`inline-flex items-center gap-1 px-2 py-1 rounded-full border text-xs ${config.color}`}>\n      <span>{config.emoji}</span>\n      <span>{config.label}</span>\n    </div>\n  );\n}\n","\"use client\";\n\nimport { useState, useEffect, useRef } from \"react\";\nimport { useAccount } from \"wagmi\";\n\ninterface Message {\n  id: string;\n  role: \"user\" | \"assistant\" | \"system\";\n  content: string;\n  timestamp: Date;\n}\n\nexport function AtlasChatWidget() {\n  const { address } = useAccount();\n  const [isOpen, setIsOpen] = useState(false);\n  const [messages, setMessages] = useState<Message[]>([\n    {\n      id: \"welcome\",\n      role: \"assistant\",\n      content: \"I'm Atlas. Ready to provide strategic guidance. \",\n      timestamp: new Date(),\n    },\n  ]);\n  const [inputValue, setInputValue] = useState(\"\");\n  const [isLoading, setIsLoading] = useState(false);\n  const messagesEndRef = useRef<HTMLDivElement>(null);\n\n  const scrollToBottom = () => {\n    messagesEndRef.current?.scrollIntoView({ behavior: \"smooth\" });\n  };\n\n  useEffect(() => {\n    scrollToBottom();\n  }, [messages]);\n\n  const handleSendMessage = async () => {\n    if (!inputValue.trim() || isLoading) return;\n\n    const userMessage: Message = {\n      id: Date.now().toString(),\n      role: \"user\",\n      content: inputValue,\n      timestamp: new Date(),\n    };\n\n    setMessages((prev) => [...prev, userMessage]);\n    const currentInput = inputValue;\n    setInputValue(\"\");\n    setIsLoading(true);\n\n    try {\n      // Call chat API with Atlas personality\n      const response = await fetch('/api/chat', {\n        method: 'POST',\n        headers: { 'Content-Type': 'application/json' },\n        body: JSON.stringify({\n          messages: [...messages, userMessage].map(m => ({\n            role: m.role,\n            content: m.content\n          })),\n          personality: 'atlas' // Specify Atlas personality\n        }),\n      });\n\n      if (!response.ok) {\n        throw new Error('API request failed');\n      }\n\n      const data = await response.json();\n\n      const aiMessage: Message = {\n        id: (Date.now() + 1).toString(),\n        role: \"assistant\",\n        content: data.reply,\n        timestamp: new Date(),\n      };\n\n      setMessages((prev) => [...prev, aiMessage]);\n    } catch (error) {\n      console.error('Chat error:', error);\n\n      // Fallback to Atlas-style response\n      const aiMessage: Message = {\n        id: (Date.now() + 1).toString(),\n        role: \"assistant\",\n        content: generateAtlasResponse(currentInput, address),\n        timestamp: new Date(),\n      };\n      setMessages((prev) => [...prev, aiMessage]);\n    } finally {\n      setIsLoading(false);\n    }\n  };\n\n  const generateAtlasResponse = (input: string, userAddress?: string): string => {\n    const lowerInput = input.toLowerCase();\n\n    if (lowerInput.includes(\"hello\") || lowerInput.includes(\"hi\") || lowerInput.includes(\"hey\")) {\n      return `Greetings${userAddress ? `, ${userAddress.slice(0, 6)}...${userAddress.slice(-4)}` : \"\"}. \\n\\nI'm Atlas - your strategic AI companion. I provide:\\n Leadership and decisive guidance\\n Risk assessment and protection strategies\\n Strategic planning and tactical analysis\\n Problem-solving with mental fortitude\\n\\nHow can I assist you today?`;\n    }\n\n    if (lowerInput.includes(\"help\") || lowerInput.includes(\"guide\") || lowerInput.includes(\"strategy\")) {\n      return `I stand ready to guide you. My strategic capabilities include:\\n\\n **Leadership** - Clear direction when you need it most\\n **Protection** - Safeguarding your interests\\n **Analysis** - Logical breakdown of complex situations\\n **Decisiveness** - Swift, confident recommendations\\n\\nWhat challenge are you facing?`;\n    }\n\n    if (lowerInput.includes(\"threat\") || lowerInput.includes(\"danger\") || lowerInput.includes(\"risk\")) {\n      return `I detect a situation requiring protective analysis. Let's assess this strategically:\\n\\n1. **Identify the threat** - What specific risks do you see?\\n2. **Evaluate severity** - How critical is the situation?\\n3. **Develop countermeasures** - What defensive strategies apply?\\n4. **Execute decisively** - Take bold action when ready\\n\\nI'm here to protect and guide you through this.`;\n    }\n\n    if (lowerInput.includes(\"decision\") || lowerInput.includes(\"choose\") || lowerInput.includes(\"option\")) {\n      return `Decision-making requires strength and clarity. Here's my strategic approach:\\n\\n **Analyze all options** - Weigh pros and cons objectively\\n **Assess risks** - Identify potential obstacles\\n **Choose boldly** - Commit to the strongest path\\n **Execute with confidence** - Follow through decisively\\n\\nWhat decision are you facing? I'll provide strategic guidance.`;\n    }\n\n    return `I understand you're inquiring about \"${input}\". \\n\\nAs your strategic AI companion, I combine:\\n Analytical power with tactical thinking\\n Mental fortitude with protective guidance\\n Leadership wisdom with decisive action\\n\\nLet's break down your question systematically. What specific aspect would you like me to analyze?`;\n  };\n\n  const handleKeyPress = (e: React.KeyboardEvent) => {\n    if (e.key === \"Enter\" && !e.shiftKey) {\n      e.preventDefault();\n      handleSendMessage();\n    }\n  };\n\n  return (\n    <>\n      {/* Large Video Avatar Button - Atlas */}\n      {!isOpen && (\n        <button\n          onClick={() => setIsOpen(true)}\n          className=\"fixed top-[550px] left-1/2 translate-x-[60px] z-50 group\"\n          aria-label=\"Open chat with Atlas AI\"\n        >\n          <div className=\"relative\">\n            {/* Pulsing glow effect - Blue theme for Atlas */}\n            <div\n              className=\"absolute inset-0 rounded-full blur-3xl opacity-75 group-hover:opacity-100 transition-opacity duration-300 animate-pulse\"\n              style={{ backgroundColor: \"#3B82F6\" }}\n            />\n\n            {/* Main avatar container - Video */}\n            <div className=\"relative w-48 h-48 rounded-full overflow-hidden border-4 border-blue-500/40 group-hover:border-blue-400/60 transition-all duration-300 group-hover:scale-110 shadow-2xl\">\n              <video\n                autoPlay\n                loop\n                muted\n                playsInline\n                className=\"w-full h-full object-cover\"\n              >\n                <source src=\"/atlas-avatar.mp4\" type=\"video/mp4\" />\n              </video>\n            </div>\n\n            {/* Status indicator */}\n            <div className=\"absolute bottom-2 right-2 w-6 h-6 bg-blue-500 rounded-full border-2 border-black animate-pulse flex items-center justify-center\">\n              <div className=\"w-3 h-3 bg-white rounded-full\" />\n            </div>\n\n            {/* Hover label */}\n            <div className=\"absolute -top-12 left-1/2 -translate-x-1/2 bg-black/90 text-white px-4 py-2 rounded-lg text-sm font-medium opacity-0 group-hover:opacity-100 transition-opacity whitespace-nowrap\">\n              Chat with Atlas! \n            </div>\n          </div>\n        </button>\n      )}\n\n      {/* Chat Window */}\n      {isOpen && (\n        <div className=\"fixed bottom-6 right-[26rem] z-50 w-96 h-[600px] bg-black/90 backdrop-blur-xl border border-blue-500/20 rounded-2xl shadow-2xl shadow-blue-500/20 flex flex-col overflow-hidden animate-in fade-in slide-in-from-bottom-5 duration-300\">\n          {/* Header */}\n          <div className=\"bg-gradient-to-br from-blue-500/20 via-slate-600/20 to-gray-600/20 border-b border-blue-500/20 px-4 py-3\">\n            <div className=\"flex justify-between items-start mb-2\">\n              <div className=\"flex items-center gap-2\">\n                <div className=\"w-12 h-12 rounded-full overflow-hidden border-2 border-blue-500/40\">\n                  <video\n                    autoPlay\n                    loop\n                    muted\n                    playsInline\n                    className=\"w-full h-full object-cover\"\n                  >\n                    <source src=\"/atlas-avatar.mp4\" type=\"video/mp4\" />\n                  </video>\n                </div>\n                <div>\n                  <div className=\"text-white font-semibold text-sm\">Atlas AI</div>\n                  <div className=\"text-gray-400 text-xs flex items-center gap-1\">\n                    <div className=\"w-2 h-2 rounded-full bg-blue-500 animate-pulse\" />\n                    Strategic Leadership\n                  </div>\n                </div>\n              </div>\n              <button\n                onClick={() => setIsOpen(false)}\n                className=\"text-gray-400 hover:text-white transition-colors text-xl\"\n                aria-label=\"Close chat\"\n              >\n                \n              </button>\n            </div>\n\n            {/* Atlas Stats */}\n            <div className=\"grid grid-cols-3 gap-2 mt-2 text-xs\">\n              <div className=\"bg-black/30 rounded px-2 py-1\">\n                <div className=\"text-gray-400\">Strength</div>\n                <div className=\"text-blue-400 font-mono\">0.9/1.0</div>\n              </div>\n              <div className=\"bg-black/30 rounded px-2 py-1\">\n                <div className=\"text-gray-400\">Protection</div>\n                <div className=\"text-slate-400 font-mono\">0.9/1.0</div>\n              </div>\n              <div className=\"bg-black/30 rounded px-2 py-1\">\n                <div className=\"text-gray-400\">Strategy</div>\n                <div className=\"text-gray-400 font-mono\">0.7/1.0</div>\n              </div>\n            </div>\n          </div>\n\n          {/* Messages */}\n          <div className=\"flex-1 overflow-y-auto p-4 space-y-4\">\n            {messages.map((message) => (\n              <div\n                key={message.id}\n                className={`flex ${message.role === \"user\" ? \"justify-end\" : \"justify-start\"}`}\n              >\n                <div\n                  className={`max-w-[80%] rounded-2xl px-4 py-3 ${\n                    message.role === \"user\"\n                      ? \"bg-gradient-to-r from-blue-600 to-slate-600 text-white\"\n                      : \"bg-white/10 text-gray-200\"\n                  }`}\n                >\n                  <div className=\"text-sm whitespace-pre-wrap break-words\">{message.content}</div>\n                  <div className=\"text-xs opacity-60 mt-1\">\n                    {message.timestamp.toLocaleTimeString([], { hour: \"2-digit\", minute: \"2-digit\" })}\n                  </div>\n                </div>\n              </div>\n            ))}\n\n            {isLoading && (\n              <div className=\"flex justify-start\">\n                <div className=\"bg-white/10 rounded-2xl px-4 py-3\">\n                  <div className=\"flex gap-1\">\n                    <div className=\"w-2 h-2 bg-blue-400 rounded-full animate-bounce\" style={{ animationDelay: \"0ms\" }} />\n                    <div className=\"w-2 h-2 bg-blue-400 rounded-full animate-bounce\" style={{ animationDelay: \"150ms\" }} />\n                    <div className=\"w-2 h-2 bg-blue-400 rounded-full animate-bounce\" style={{ animationDelay: \"300ms\" }} />\n                  </div>\n                </div>\n              </div>\n            )}\n\n            <div ref={messagesEndRef} />\n          </div>\n\n          {/* Input */}\n          <div className=\"border-t border-white/10 p-4\">\n            <div className=\"flex gap-2\">\n              <input\n                type=\"text\"\n                value={inputValue}\n                onChange={(e) => setInputValue(e.target.value)}\n                onKeyPress={handleKeyPress}\n                placeholder=\"Ask Atlas for guidance...\"\n                className=\"flex-1 bg-white/10 border border-white/10 rounded-lg px-4 py-2 text-white placeholder-gray-400 focus:outline-none focus:border-blue-500 transition-colors text-sm\"\n                disabled={isLoading}\n              />\n              <button\n                onClick={handleSendMessage}\n                disabled={!inputValue.trim() || isLoading}\n                className=\"bg-gradient-to-r from-blue-600 to-slate-700 text-white px-4 py-2 rounded-lg hover:opacity-90 disabled:opacity-50 disabled:cursor-not-allowed transition-opacity text-sm font-semibold shadow-lg shadow-blue-500/30\"\n              >\n                \n              </button>\n            </div>\n            <div className=\"text-xs text-gray-500 mt-2 text-center\">\n              <span>Atlas  Strategic Leadership AI  {messages.length} messages</span>\n            </div>\n          </div>\n        </div>\n      )}\n    </>\n  );\n}\n"],"names":[],"mappings":"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","ignoreList":[1,2,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20,21,22,23,24]}