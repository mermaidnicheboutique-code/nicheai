import { jsx } from "react/jsx-runtime";
import { useLifecycleStatus } from "../../internal/hooks/useLifecycleStatus.js";
import { openPopup } from "../../internal/utils/openPopup.js";
import { createContext, useContext, useState, useRef, useCallback, useEffect } from "react";
import { base } from "viem/chains";
import { useAccount, useConnect, useSwitchChain, useSendCalls, useCallsStatus, useWaitForTransactionReceipt } from "wagmi";
import { coinbaseWallet } from "wagmi/connectors";
import { useAnalytics } from "../../core/analytics/hooks/useAnalytics.js";
import { CheckoutEvent } from "../../core/analytics/types.js";
import { useValue } from "../../internal/hooks/useValue.js";
import { isUserRejectedRequestError } from "../../transaction/utils/isUserRejectedRequestError.js";
import { useOnchainKit } from "../../useOnchainKit.js";
import { useIsWalletACoinbaseSmartWallet } from "../../wallet/hooks/useIsWalletACoinbaseSmartWallet.js";
import { CHECKOUT_LIFECYCLE_STATUS, GENERIC_ERROR_MESSAGE, CheckoutErrorCode, USER_REJECTED_ERROR, NO_CONNECTED_ADDRESS_ERROR, NO_CONTRACTS_ERROR } from "../constants.js";
import { useCommerceContracts } from "../hooks/useCommerceContracts.js";
import { ONRAMP_POPUP_WIDTH, ONRAMP_POPUP_HEIGHT } from "../../fund/constants.js";
import { normalizeTransactionId, normalizeStatus } from "../../internal/utils/normalizeWagmi.js";
const emptyContext = {};
const CheckoutContext = createContext(emptyContext);
function useCheckoutContext() {
  const context = useContext(CheckoutContext);
  if (context === emptyContext) {
    throw new Error("useCheckoutContext must be used within a Checkout component");
  }
  return context;
}
function CheckoutProvider({
  chargeHandler,
  children,
  isSponsored,
  onStatus,
  productId
}) {
  var _a, _b;
  const {
    config: {
      appearance,
      paymaster
    } = {
      appearance: {
        name: void 0,
        logo: void 0
      },
      paymaster: void 0
    }
  } = useOnchainKit();
  const {
    address,
    chainId,
    isConnected
  } = useAccount();
  const {
    connectAsync
  } = useConnect();
  const {
    switchChainAsync
  } = useSwitchChain();
  const [chargeId, setChargeId] = useState("");
  const [transactionId, setTransactionId] = useState("");
  const [errorMessage, setErrorMessage] = useState("");
  const isSmartWallet = useIsWalletACoinbaseSmartWallet();
  const {
    sendAnalytics
  } = useAnalytics();
  const fetchedDataUseEffect = useRef(false);
  const fetchedDataHandleSubmit = useRef(false);
  const userRejectedRef = useRef(false);
  const contractsRef = useRef(null);
  const insufficientBalanceRef = useRef(false);
  const priceInUSDCRef = useRef("");
  const [lifecycleStatus, updateLifecycleStatus] = useLifecycleStatus({
    statusName: CHECKOUT_LIFECYCLE_STATUS.INIT,
    statusData: {}
  });
  const fetchContracts = useCommerceContracts({
    chargeHandler,
    productId
  });
  const fetchData = useCallback(async (address2) => {
    updateLifecycleStatus({
      statusName: CHECKOUT_LIFECYCLE_STATUS.FETCHING_DATA,
      statusData: {}
    });
    const {
      contracts,
      chargeId: hydratedChargeId,
      insufficientBalance,
      priceInUSDC,
      error
    } = await fetchContracts(address2);
    if (error) {
      setErrorMessage(GENERIC_ERROR_MESSAGE);
      updateLifecycleStatus({
        statusName: CHECKOUT_LIFECYCLE_STATUS.ERROR,
        statusData: {
          code: CheckoutErrorCode.UNEXPECTED_ERROR,
          error: error.name,
          message: error.message
        }
      });
      return;
    }
    setChargeId(hydratedChargeId);
    contractsRef.current = contracts;
    insufficientBalanceRef.current = insufficientBalance;
    priceInUSDCRef.current = priceInUSDC;
    updateLifecycleStatus({
      statusName: CHECKOUT_LIFECYCLE_STATUS.READY,
      statusData: {
        chargeId,
        contracts: contractsRef.current || []
      }
    });
  }, [chargeId, fetchContracts, updateLifecycleStatus]);
  const {
    status,
    sendCallsAsync
  } = useSendCalls({
    /* v8 ignore start */
    mutation: {
      onSuccess: (data2) => {
        setTransactionId(normalizeTransactionId(data2));
      }
    }
    /* v8 ignore stop */
  });
  const {
    data
  } = useCallsStatus({
    id: transactionId,
    query: {
      /* v8 ignore next 5 */
      refetchInterval: (query) => {
        var _a2;
        return normalizeStatus((_a2 = query.state.data) == null ? void 0 : _a2.status) === "success" ? false : 1e3;
      },
      enabled: !!transactionId
    }
  });
  const transactionHash = (_b = (_a = data == null ? void 0 : data.receipts) == null ? void 0 : _a[0]) == null ? void 0 : _b.transactionHash;
  const {
    data: receipt
  } = useWaitForTransactionReceipt({
    hash: transactionHash
  });
  useEffect(() => {
    onStatus == null ? void 0 : onStatus(lifecycleStatus);
  }, [
    lifecycleStatus,
    lifecycleStatus.statusData,
    // Keep statusData, so that the effect runs when it changes
    lifecycleStatus.statusName,
    // Keep statusName, so that the effect runs when it changes
    onStatus
  ]);
  useEffect(() => {
    if (status === "pending") {
      updateLifecycleStatus({
        statusName: CHECKOUT_LIFECYCLE_STATUS.PENDING,
        statusData: {}
      });
    }
  }, [status, updateLifecycleStatus]);
  useEffect(() => {
    if (!receipt) {
      return;
    }
    updateLifecycleStatus({
      statusName: CHECKOUT_LIFECYCLE_STATUS.SUCCESS,
      statusData: {
        transactionReceipts: [receipt],
        chargeId,
        receiptUrl: `https://commerce.coinbase.com/pay/${chargeId}/receipt`
      }
    });
  }, [chargeId, receipt, updateLifecycleStatus]);
  useEffect(() => {
    if (lifecycleStatus.statusName === CHECKOUT_LIFECYCLE_STATUS.INIT && address && !fetchedDataHandleSubmit.current) {
      fetchedDataUseEffect.current = true;
      fetchData(address);
    }
  }, [address, fetchData, lifecycleStatus]);
  const handleAnalytics = useCallback((event, data2) => {
    sendAnalytics(event, data2);
  }, [sendAnalytics]);
  const handleSubmit = useCallback(async () => {
    var _a2;
    try {
      handleAnalytics(CheckoutEvent.CheckoutInitiated, {
        address,
        amount: Number(priceInUSDCRef.current),
        productId: productId || ""
      });
      if (lifecycleStatus.statusName === CHECKOUT_LIFECYCLE_STATUS.SUCCESS) {
        window.open(`https://commerce.coinbase.com/pay/${chargeId}/receipt`, "_blank", "noopener,noreferrer");
        return;
      }
      if (errorMessage === USER_REJECTED_ERROR) {
        setErrorMessage("");
      }
      let connectedAddress = address;
      let connectedChainId = chainId;
      if (!isConnected || !isSmartWallet) {
        fetchedDataHandleSubmit.current = true;
        const {
          accounts,
          chainId: _connectedChainId
        } = await connectAsync({
          /* v8 ignore next 5 */
          connector: coinbaseWallet({
            appName: (appearance == null ? void 0 : appearance.name) ?? void 0,
            appLogoUrl: (appearance == null ? void 0 : appearance.logo) ?? void 0,
            preference: "smartWalletOnly"
          })
        });
        connectedAddress = accounts[0];
        connectedChainId = _connectedChainId;
      }
      if (!connectedAddress) {
        setErrorMessage(GENERIC_ERROR_MESSAGE);
        updateLifecycleStatus({
          statusName: CHECKOUT_LIFECYCLE_STATUS.ERROR,
          statusData: {
            code: CheckoutErrorCode.UNEXPECTED_ERROR,
            error: NO_CONNECTED_ADDRESS_ERROR,
            message: NO_CONNECTED_ADDRESS_ERROR
          }
        });
        return;
      }
      if (!fetchedDataUseEffect.current && !userRejectedRef.current) {
        await fetchData(connectedAddress);
      }
      if (connectedChainId !== base.id) {
        await switchChainAsync({
          chainId: base.id
        });
      }
      if (insufficientBalanceRef.current && priceInUSDCRef.current) {
        openPopup({
          url: `https://keys.coinbase.com/fund?asset=USDC&chainId=8453&presetCryptoAmount=${priceInUSDCRef.current}`,
          target: "_blank",
          height: ONRAMP_POPUP_HEIGHT,
          width: ONRAMP_POPUP_WIDTH
        });
        insufficientBalanceRef.current = false;
        priceInUSDCRef.current = void 0;
        fetchedDataUseEffect.current = false;
        return;
      }
      if (!contractsRef.current || contractsRef.current.length === 0) {
        setErrorMessage(GENERIC_ERROR_MESSAGE);
        updateLifecycleStatus({
          statusName: CHECKOUT_LIFECYCLE_STATUS.ERROR,
          statusData: {
            code: CheckoutErrorCode.UNEXPECTED_ERROR,
            error: NO_CONTRACTS_ERROR,
            message: NO_CONTRACTS_ERROR
          }
        });
        return;
      }
      await sendCallsAsync({
        calls: contractsRef.current.map((contract) => {
          return {
            to: contract.address,
            abi: contract.abi,
            functionName: contract.functionName,
            args: contract.args
          };
        }),
        capabilities: isSponsored && paymaster ? {
          paymasterService: {
            url: paymaster
          }
        } : void 0
      });
    } catch (error) {
      handleAnalytics(CheckoutEvent.CheckoutFailure, {
        error: error instanceof Error ? error.message : "Checkout failed",
        metadata: {
          error: JSON.stringify(error)
        }
      });
      const isUserRejectedError = ((_a2 = error.message) == null ? void 0 : _a2.includes("User denied connection request")) || isUserRejectedRequestError(error);
      const errorCode = isUserRejectedError ? CheckoutErrorCode.USER_REJECTED_ERROR : CheckoutErrorCode.UNEXPECTED_ERROR;
      const errorMessage2 = isUserRejectedError ? USER_REJECTED_ERROR : GENERIC_ERROR_MESSAGE;
      if (isUserRejectedError) {
        userRejectedRef.current = true;
      }
      setErrorMessage(errorMessage2);
      updateLifecycleStatus({
        statusName: CHECKOUT_LIFECYCLE_STATUS.ERROR,
        statusData: {
          code: errorCode,
          error: JSON.stringify(error),
          message: errorMessage2
        }
      });
    }
  }, [address, appearance, chainId, chargeId, connectAsync, errorMessage, fetchData, isConnected, isSmartWallet, isSponsored, lifecycleStatus.statusName, paymaster, switchChainAsync, updateLifecycleStatus, sendCallsAsync, handleAnalytics, productId]);
  const value = useValue({
    errorMessage,
    lifecycleStatus,
    onSubmit: handleSubmit,
    updateLifecycleStatus
  });
  return /* @__PURE__ */ jsx(CheckoutContext.Provider, { value, children });
}
export {
  CheckoutContext,
  CheckoutProvider,
  useCheckoutContext
};
//# sourceMappingURL=CheckoutProvider.js.map
