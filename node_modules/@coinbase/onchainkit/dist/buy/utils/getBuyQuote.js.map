{"version":3,"file":"getBuyQuote.js","sources":["../../../src/buy/utils/getBuyQuote.ts"],"sourcesContent":["import { getSwapQuote } from '@/api/getSwapQuote';\nimport type { GetSwapQuoteParams, GetSwapQuoteResponse } from '@/api/types';\nimport { RequestContext } from '@/core/network/constants';\nimport { formatTokenAmount } from '@/internal/utils/formatTokenAmount';\nimport type { SwapError, SwapUnit } from '../../swap/types';\nimport { isSwapError } from '../../swap/utils/isSwapError';\nimport type { Token } from '../../token';\nimport type { GetBuyQuoteResponseType } from '../types';\n\n/**\n * Parameters for getting a buy quote, extending GetSwapQuoteParams but omitting 'from'\n */\ntype GetBuyQuoteParams = Omit<GetSwapQuoteParams, 'from'> & {\n  /** Optional swap unit for the 'from' token */\n  fromSwapUnit?: SwapUnit;\n  /** Optional 'from' token */\n  from?: Token;\n};\n\n/**\n * Fetches a quote for a swap, but only if the from and to tokens are different.\n */\nexport async function getBuyQuote({\n  amount,\n  from,\n  maxSlippage,\n  to,\n  useAggregator,\n  fromSwapUnit,\n}: GetBuyQuoteParams): Promise<GetBuyQuoteResponseType> {\n  // only fetch quote if the from token is provided\n  if (!from) {\n    return { response: undefined, formattedFromAmount: '', error: undefined };\n  }\n\n  let response: GetSwapQuoteResponse | undefined;\n  // only fetch quote if the from and to tokens are different\n  if (to?.symbol !== from?.symbol) {\n    // switching to and from here\n    // instead of getting a quote for how much of X do we need to sell to get the input token amount\n    // we can get a quote for how much of X we will receive if we sell the input token amount\n    response = await getSwapQuote(\n      {\n        amount,\n        amountReference: 'from',\n        from: to,\n        maxSlippage,\n        to: from,\n        useAggregator,\n      },\n      RequestContext.Buy,\n    );\n  }\n\n  let formattedFromAmount = '';\n  if (response && !isSwapError(response)) {\n    formattedFromAmount = response?.toAmount\n      ? formatTokenAmount(response.toAmount, response.to.decimals)\n      : '';\n\n    fromSwapUnit?.setAmountUSD(response?.toAmountUSD || '');\n    fromSwapUnit?.setAmount(formattedFromAmount || '');\n  }\n\n  let error: SwapError | undefined;\n  if (isSwapError(response)) {\n    error = response;\n    response = undefined;\n  }\n\n  return { response, formattedFromAmount, error };\n}\n"],"names":["getBuyQuote","amount","from","maxSlippage","to","useAggregator","fromSwapUnit","response","undefined","formattedFromAmount","error","symbol","getSwapQuote","amountReference","RequestContext","Buy","isSwapError","toAmount","formatTokenAmount","decimals","setAmountUSD","toAmountUSD","setAmount"],"mappings":";;;;AAsBA,eAAsBA,YAAY;AAAA,EAChCC;AAAAA,EACAC;AAAAA,EACAC;AAAAA,EACAC;AAAAA,EACAC;AAAAA,EACAC;AACiB,GAAqC;AAEtD,MAAI,CAACJ,MAAM;AACF,WAAA;AAAA,MAAEK,UAAUC;AAAAA,MAAWC,qBAAqB;AAAA,MAAIC,OAAOF;AAAAA,IAAU;AAAA,EAAA;AAGtED,MAAAA;AAEAH,OAAAA,yBAAIO,aAAWT,6BAAMS,SAAQ;AAI/BJ,eAAW,MAAMK,aACf;AAAA,MACEX;AAAAA,MACAY,iBAAiB;AAAA,MACjBX,MAAME;AAAAA,MACND;AAAAA,MACAC,IAAIF;AAAAA,MACJG;AAAAA,IAAAA,GAEFS,eAAeC,GACjB;AAAA,EAAA;AAGF,MAAIN,sBAAsB;AAC1B,MAAIF,YAAY,CAACS,YAAYT,QAAQ,GAAG;AAChBA,2BAAAA,qCAAUU,YAC5BC,kBAAkBX,SAASU,UAAUV,SAASH,GAAGe,QAAQ,IACzD;AAEUC,iDAAAA,cAAab,qCAAUc,gBAAe;AACtCC,iDAAAA,UAAUb,uBAAuB;AAAA,EAAE;AAG/CC,MAAAA;AACAM,MAAAA,YAAYT,QAAQ,GAAG;AACjBA,YAAAA;AACGC,eAAAA;AAAAA,EAAAA;AAGN,SAAA;AAAA,IAAED;AAAAA,IAAUE;AAAAA,IAAqBC;AAAAA,EAAM;AAChD;"}