{"version":3,"file":"getNames.js","sources":["../../../src/identity/utils/getNames.ts"],"sourcesContent":["import type {\n  Basename,\n  GetNameReturnType,\n  GetNamesParams,\n} from '@/identity/types';\nimport { mainnet } from 'viem/chains';\nimport { getChainPublicClient } from '../../core/network/getChainPublicClient';\nimport { isBase } from '../../core/utils/isBase';\nimport { isEthereum } from '../../core/utils/isEthereum';\nimport L2ResolverAbi from '../abis/L2ResolverAbi';\nimport { RESOLVER_ADDRESSES_BY_CHAIN_ID } from '../constants';\nimport { convertReverseNodeToBytes } from './convertReverseNodeToBytes';\nimport { getAddresses } from './getAddresses';\n\n/**\n * An asynchronous function to fetch multiple Basenames or Ethereum Name Service (ENS)\n * names for a given array of Ethereum addresses in a single batch request.\n * It returns an array of ENS names in the same order as the input addresses.\n */\n// eslint-disable-next-line complexity\nexport const getNames = async ({\n  addresses,\n  chain = mainnet,\n}: GetNamesParams): Promise<GetNameReturnType[]> => {\n  if (!addresses || addresses.length === 0) {\n    return [];\n  }\n\n  const chainIsBase = isBase({ chainId: chain.id });\n  const chainIsEthereum = isEthereum({ chainId: chain.id });\n  const chainSupportsUniversalResolver = chainIsEthereum || chainIsBase;\n\n  if (!chainSupportsUniversalResolver) {\n    return Promise.reject(\n      'ChainId not supported, name resolution is only supported on Ethereum and Base.',\n    );\n  }\n\n  const client = getChainPublicClient(chain);\n  const results: GetNameReturnType[] = Array(addresses.length).fill(null);\n\n  if (chainIsBase) {\n    try {\n      // Create batch of calls for the multicall contract\n      const calls = addresses.map((address) => ({\n        address: RESOLVER_ADDRESSES_BY_CHAIN_ID[chain.id],\n        abi: L2ResolverAbi,\n        functionName: 'name',\n        args: [convertReverseNodeToBytes(address, chain.id)],\n      }));\n\n      const batchResults = await client.multicall({\n        contracts: calls,\n        allowFailure: true,\n      });\n\n      // Collect all successfully resolved basenames for batch verification\n      const basenamesWithIndices: Array<{ basename: Basename; index: number }> =\n        [];\n\n      for (let index = 0; index < batchResults.length; index++) {\n        const result = batchResults[index];\n        if (result.status === 'success' && result.result) {\n          const basename = result.result as Basename;\n          basenamesWithIndices.push({ basename, index });\n        }\n      }\n\n      if (basenamesWithIndices.length > 0) {\n        try {\n          // Verify basenames with forward resolution using batch processing\n          const basenames = basenamesWithIndices.map(\n            ({ basename }) => basename,\n          );\n          const resolvedAddresses = await getAddresses({\n            names: basenames,\n          });\n\n          // Update results with validated basenames\n          for (let i = 0; i < basenamesWithIndices.length; i++) {\n            const { basename, index } = basenamesWithIndices[i];\n            const resolvedAddress = resolvedAddresses[i];\n\n            if (\n              resolvedAddress &&\n              resolvedAddress.toLowerCase() === addresses[index].toLowerCase()\n            ) {\n              results[index] = basename;\n            }\n          }\n        } catch (error) {\n          console.error(\n            'Error during batch basename forward resolution verification:',\n            error,\n          );\n        }\n      }\n\n      // If we have all results, return them\n      if (results.every((result) => result !== null)) {\n        return results;\n      }\n    } catch (error) {\n      console.error('Error resolving Base names in batch:', error);\n    }\n  }\n\n  // Default fallback to mainnet\n  // ENS resolution is not well-supported on Base, so want to ensure that we fall back to mainnet\n  const fallbackClient = getChainPublicClient(mainnet);\n\n  // For addresses that don't have a result yet, try ENS resolution on mainnet\n  const unresolvedIndices = results\n    .map((result, index) => (result === null ? index : -1))\n    .filter((index) => index !== -1);\n\n  if (unresolvedIndices.length > 0) {\n    try {\n      const ensPromises = unresolvedIndices.map((index) =>\n        fallbackClient\n          .getEnsName({\n            address: addresses[index],\n          })\n          .catch((error) => {\n            console.error(\n              `Error resolving ENS name for ${addresses[index]}:`,\n              error,\n            );\n            return null; // Return null for failed resolutions\n          }),\n      );\n\n      const ensResults = await Promise.all(ensPromises);\n\n      // Collect all successfully resolved ENS names for batch verification\n      const ensNamesWithIndices: Array<{\n        ensName: string;\n        originalIndex: number;\n      }> = [];\n\n      for (let i = 0; i < ensResults.length; i++) {\n        const ensName = ensResults[i];\n        const originalIndex = unresolvedIndices[i];\n\n        if (ensName) {\n          ensNamesWithIndices.push({ ensName, originalIndex });\n        }\n      }\n\n      if (ensNamesWithIndices.length > 0) {\n        try {\n          // Verify ENS names with forward resolution using batch processing\n          const ensNames = ensNamesWithIndices.map(({ ensName }) => ensName);\n          const resolvedAddresses = await getAddresses({\n            names: ensNames,\n          });\n\n          // Update results with validated ENS names\n          for (let i = 0; i < ensNamesWithIndices.length; i++) {\n            const { ensName, originalIndex } = ensNamesWithIndices[i];\n            const resolvedAddress = resolvedAddresses[i];\n\n            if (\n              resolvedAddress &&\n              resolvedAddress.toLowerCase() ===\n                addresses[originalIndex].toLowerCase()\n            ) {\n              results[originalIndex] = ensName;\n            }\n          }\n        } catch (error) {\n          console.error(\n            'Error during batch ENS forward resolution verification:',\n            error,\n          );\n        }\n      }\n    } catch (error) {\n      console.error('Error resolving ENS names in batch:', error);\n    }\n  }\n\n  return results;\n};\n"],"names":["getNames","addresses","chain","mainnet","length","chainIsBase","isBase","chainId","id","chainIsEthereum","isEthereum","chainSupportsUniversalResolver","Promise","reject","client","getChainPublicClient","results","Array","fill","calls","map","address","RESOLVER_ADDRESSES_BY_CHAIN_ID","abi","L2ResolverAbi","functionName","args","convertReverseNodeToBytes","batchResults","multicall","contracts","allowFailure","basenamesWithIndices","index","result","status","basename","push","basenames","resolvedAddresses","getAddresses","names","i","resolvedAddress","toLowerCase","error","every","fallbackClient","unresolvedIndices","filter","ensPromises","getEnsName","catch","console","ensResults","all","ensNamesWithIndices","ensName","originalIndex","ensNames"],"mappings":";;;;;;;;AAoBO,MAAMA,WAAW,OAAO;AAAA,EAC7BC;AAAAA,EACAC,QAAQC;AACM,MAAoC;AAClD,MAAI,CAACF,aAAaA,UAAUG,WAAW,GAAG;AACxC,WAAO,CAAE;AAAA,EAAA;AAGX,QAAMC,cAAcC,OAAO;AAAA,IAAEC,SAASL,MAAMM;AAAAA,EAAAA,CAAI;AAChD,QAAMC,kBAAkBC,WAAW;AAAA,IAAEH,SAASL,MAAMM;AAAAA,EAAAA,CAAI;AACxD,QAAMG,iCAAiCF,mBAAmBJ;AAE1D,MAAI,CAACM,gCAAgC;AAC5BC,WAAAA,QAAQC,OACb,gFACF;AAAA,EAAA;AAGIC,QAAAA,SAASC,qBAAqBb,KAAK;AACzC,QAAMc,UAA+BC,MAAMhB,UAAUG,MAAM,EAAEc,KAAK,IAAI;AAEtE,MAAIb,aAAa;AACX,QAAA;AAEIc,YAAAA,QAAQlB,UAAUmB,IAAKC,CAAa,aAAA;AAAA,QACxCA,SAASC,+BAA+BpB,MAAMM,EAAE;AAAA,QAChDe,KAAKC;AAAAA,QACLC,cAAc;AAAA,QACdC,MAAM,CAACC,0BAA0BN,SAASnB,MAAMM,EAAE,CAAC;AAAA,MAAA,EACnD;AAEIoB,YAAAA,eAAe,MAAMd,OAAOe,UAAU;AAAA,QAC1CC,WAAWX;AAAAA,QACXY,cAAc;AAAA,MAAA,CACf;AAGD,YAAMC,uBACJ,CAAE;AAEJ,eAASC,QAAQ,GAAGA,QAAQL,aAAaxB,QAAQ6B,SAAS;AAClDC,cAAAA,SAASN,aAAaK,KAAK;AACjC,YAAIC,OAAOC,WAAW,aAAaD,OAAOA,QAAQ;AAChD,gBAAME,WAAWF,OAAOA;AACxBF,+BAAqBK,KAAK;AAAA,YAAED;AAAAA,YAAUH;AAAAA,UAAAA,CAAO;AAAA,QAAA;AAAA,MAC/C;AAGED,UAAAA,qBAAqB5B,SAAS,GAAG;AAC/B,YAAA;AAEIkC,gBAAAA,YAAYN,qBAAqBZ,IACrC,CAAC;AAAA,YAAEgB;AAAAA,gBAAeA,QACpB;AACMG,gBAAAA,oBAAoB,MAAMC,aAAa;AAAA,YAC3CC,OAAOH;AAAAA,UAAAA,CACR;AAGD,mBAASI,IAAI,GAAGA,IAAIV,qBAAqB5B,QAAQsC,KAAK;AAC9C,kBAAA;AAAA,cAAEN;AAAAA,cAAUH;AAAAA,YAAAA,IAAUD,qBAAqBU,CAAC;AAC5CC,kBAAAA,kBAAkBJ,kBAAkBG,CAAC;AAGzCC,gBAAAA,mBACAA,gBAAgBC,YAAY,MAAM3C,UAAUgC,KAAK,EAAEW,eACnD;AACA5B,sBAAQiB,KAAK,IAAIG;AAAAA,YAAAA;AAAAA,UACnB;AAAA,iBAEKS,OAAO;AACNA,kBAAAA,MACN,gEACAA,KACF;AAAA,QAAA;AAAA,MACF;AAIF,UAAI7B,QAAQ8B,MAAOZ,CAAWA,WAAAA,WAAW,IAAI,GAAG;AACvClB,eAAAA;AAAAA,MAAAA;AAAAA,aAEF6B,OAAO;AACNA,cAAAA,MAAM,wCAAwCA,KAAK;AAAA,IAAA;AAAA,EAC7D;AAKIE,QAAAA,iBAAiBhC,qBAAqBZ,OAAO;AAGnD,QAAM6C,oBAAoBhC,QACvBI,IAAI,CAACc,QAAQD,UAAWC,WAAW,OAAOD,QAAQ,EAAG,EACrDgB,OAAQhB,CAAAA,UAAUA,UAAU,EAAE;AAE7Be,MAAAA,kBAAkB5C,SAAS,GAAG;AAC5B,QAAA;AACF,YAAM8C,cAAcF,kBAAkB5B,IAAKa,CAAAA,UACzCc,eACGI,WAAW;AAAA,QACV9B,SAASpB,UAAUgC,KAAK;AAAA,MAAA,CACzB,EACAmB,MAAOP,CAAU,UAAA;AAChBQ,gBAAQR,MACN,gCAAgC5C,UAAUgC,KAAK,CAAC,KAChDY,KACF;AACO,eAAA;AAAA,MAAA,CACR,CACL;AAEA,YAAMS,aAAa,MAAM1C,QAAQ2C,IAAIL,WAAW;AAGhD,YAAMM,sBAGD,CAAE;AAEP,eAASd,IAAI,GAAGA,IAAIY,WAAWlD,QAAQsC,KAAK;AACpCe,cAAAA,UAAUH,WAAWZ,CAAC;AACtBgB,cAAAA,gBAAgBV,kBAAkBN,CAAC;AAEzC,YAAIe,SAAS;AACXD,8BAAoBnB,KAAK;AAAA,YAAEoB;AAAAA,YAASC;AAAAA,UAAAA,CAAe;AAAA,QAAA;AAAA,MACrD;AAGEF,UAAAA,oBAAoBpD,SAAS,GAAG;AAC9B,YAAA;AAEIuD,gBAAAA,WAAWH,oBAAoBpC,IAAI,CAAC;AAAA,YAAEqC;AAAAA,gBAAcA,OAAO;AAC3DlB,gBAAAA,oBAAoB,MAAMC,aAAa;AAAA,YAC3CC,OAAOkB;AAAAA,UAAAA,CACR;AAGD,mBAASjB,IAAI,GAAGA,IAAIc,oBAAoBpD,QAAQsC,KAAK;AAC7C,kBAAA;AAAA,cAAEe;AAAAA,cAASC;AAAAA,YAAAA,IAAkBF,oBAAoBd,CAAC;AAClDC,kBAAAA,kBAAkBJ,kBAAkBG,CAAC;AAGzCC,gBAAAA,mBACAA,gBAAgBC,YAAY,MAC1B3C,UAAUyD,aAAa,EAAEd,eAC3B;AACA5B,sBAAQ0C,aAAa,IAAID;AAAAA,YAAAA;AAAAA,UAC3B;AAAA,iBAEKZ,OAAO;AACNA,kBAAAA,MACN,2DACAA,KACF;AAAA,QAAA;AAAA,MACF;AAAA,aAEKA,OAAO;AACNA,cAAAA,MAAM,uCAAuCA,KAAK;AAAA,IAAA;AAAA,EAC5D;AAGK7B,SAAAA;AACT;"}