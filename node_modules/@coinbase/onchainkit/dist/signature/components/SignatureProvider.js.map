{"version":3,"file":"SignatureProvider.js","sources":["../../../src/signature/components/SignatureProvider.tsx"],"sourcesContent":["import { createContext, useCallback, useContext, useMemo } from 'react';\nimport { useIsMounted } from 'usehooks-ts';\nimport type { APIError } from '@/api/types';\nimport { useLifecycleStatus } from '@/internal/hooks/useLifecycleStatus';\nimport { GENERIC_ERROR_MESSAGE } from '@/transaction/constants';\nimport { isUserRejectedRequestError } from '@/transaction/utils/isUserRejectedRequestError';\nimport { useSignData } from '../hooks/useSignData';\nimport { type LifecycleStatus, type MessageData } from '../types';\n\nexport type SignatureContextType = {\n  lifecycleStatus: LifecycleStatus;\n  handleSign: () => Promise<void>;\n};\n\nconst SignatureContext = createContext<SignatureContextType | null>(null);\n\nexport function useSignatureContext() {\n  const context = useContext(SignatureContext);\n  if (!context) {\n    throw new Error(\n      'useSignatureContext must be used within a SignatureProvider',\n    );\n  }\n  return context;\n}\n\nexport type SignatureProviderProps = {\n  children: React.ReactNode;\n} & {\n  onSuccess?: (signature: string) => void;\n  onError?: (error: APIError) => void;\n  onStatus?: (status: LifecycleStatus) => void;\n  resetAfter?: number;\n} & MessageData;\n\nexport function SignatureProvider({\n  children,\n  onSuccess,\n  onError,\n  onStatus,\n  domain,\n  types,\n  message,\n  primaryType,\n  resetAfter,\n}: SignatureProviderProps) {\n  const isMounted = useIsMounted();\n  const { signData, resetSignData } = useSignData();\n\n  const [lifecycleStatus, updateLifecycleStatus] =\n    useLifecycleStatus<LifecycleStatus>(\n      {\n        statusName: 'init',\n        statusData: null,\n      },\n      {\n        onStatus: (status) => {\n          onStatus?.(status);\n          if (status.statusName === 'error') {\n            onError?.(status.statusData);\n          }\n\n          if (status.statusName !== 'success') {\n            return;\n          }\n\n          onSuccess?.(status.statusData.signature);\n\n          if (resetAfter) {\n            setTimeout(() => {\n              if (!isMounted()) return;\n              resetSignData();\n              updateLifecycleStatus({\n                statusName: 'init',\n                statusData: null,\n              });\n            }, resetAfter);\n          }\n        },\n      },\n    );\n\n  const handleSign = useCallback(async () => {\n    updateLifecycleStatus({\n      statusName: 'pending',\n    });\n\n    try {\n      const signature = await signData({\n        domain,\n        types,\n        message,\n        primaryType,\n      });\n\n      updateLifecycleStatus({\n        statusName: 'success',\n        statusData: {\n          signature,\n        },\n      });\n    } catch (err) {\n      const errorMessage = isUserRejectedRequestError(err)\n        ? 'Request denied.'\n        : GENERIC_ERROR_MESSAGE;\n      updateLifecycleStatus({\n        statusName: 'error',\n        statusData: {\n          code: 'SmSPc01', // Signature module SignatureProvider component 01 error\n          error: JSON.stringify(err),\n          message: errorMessage,\n        },\n      });\n    }\n  }, [domain, types, message, primaryType, updateLifecycleStatus, signData]);\n\n  const contextValue = useMemo(\n    () => ({\n      lifecycleStatus,\n      handleSign,\n    }),\n    [lifecycleStatus, handleSign],\n  );\n\n  return (\n    <SignatureContext.Provider value={contextValue}>\n      {children}\n    </SignatureContext.Provider>\n  );\n}\n"],"names":["SignatureContext","createContext","useSignatureContext","context","useContext","Error","SignatureProvider","children","onSuccess","onError","onStatus","domain","types","message","primaryType","resetAfter","isMounted","useIsMounted","signData","resetSignData","useSignData","lifecycleStatus","updateLifecycleStatus","useLifecycleStatus","statusName","statusData","status","signature","setTimeout","handleSign","useCallback","err","errorMessage","isUserRejectedRequestError","GENERIC_ERROR_MESSAGE","code","error","JSON","stringify","contextValue","useMemo"],"mappings":";;;;;;;AAcA,MAAMA,mBAAmBC,cAA2C,IAAI;AAEjE,SAASC,sBAAsB;AAC9BC,QAAAA,UAAUC,WAAWJ,gBAAgB;AAC3C,MAAI,CAACG,SAAS;AACN,UAAA,IAAIE,MACR,6DACF;AAAA,EAAA;AAEKF,SAAAA;AACT;AAWO,SAASG,kBAAkB;AAAA,EAChCC;AAAAA,EACAC;AAAAA,EACAC;AAAAA,EACAC;AAAAA,EACAC;AAAAA,EACAC;AAAAA,EACAC;AAAAA,EACAC;AAAAA,EACAC;AACsB,GAAG;AACzB,QAAMC,YAAYC,aAAa;AACzB,QAAA;AAAA,IAAEC;AAAAA,IAAUC;AAAAA,MAAkBC,YAAY;AAEhD,QAAM,CAACC,iBAAiBC,qBAAqB,IAC3CC,mBACE;AAAA,IACEC,YAAY;AAAA,IACZC,YAAY;AAAA,EAAA,GAEd;AAAA,IACEf,UAAWgB,CAAW,WAAA;AACpBhB,2CAAWgB;AACPA,UAAAA,OAAOF,eAAe,SAAS;AACjCf,2CAAUiB,OAAOD;AAAAA,MAAU;AAGzBC,UAAAA,OAAOF,eAAe,WAAW;AACnC;AAAA,MAAA;AAGUE,6CAAAA,OAAOD,WAAWE;AAE9B,UAAIZ,YAAY;AACda,mBAAW,MAAM;AACX,cAAA,CAACZ,YAAa;AACJ,wBAAA;AACQ,gCAAA;AAAA,YACpBQ,YAAY;AAAA,YACZC,YAAY;AAAA,UAAA,CACb;AAAA,WACAV,UAAU;AAAA,MAAA;AAAA,IACf;AAAA,EACF,CAEJ;AAEIc,QAAAA,aAAaC,YAAY,YAAY;AACnB,0BAAA;AAAA,MACpBN,YAAY;AAAA,IAAA,CACb;AAEG,QAAA;AACIG,YAAAA,YAAY,MAAMT,SAAS;AAAA,QAC/BP;AAAAA,QACAC;AAAAA,QACAC;AAAAA,QACAC;AAAAA,MAAAA,CACD;AAEqB,4BAAA;AAAA,QACpBU,YAAY;AAAA,QACZC,YAAY;AAAA,UACVE;AAAAA,QAAAA;AAAAA,MACF,CACD;AAAA,aACMI,KAAK;AACZ,YAAMC,eAAeC,2BAA2BF,GAAG,IAC/C,oBACAG;AACkB,4BAAA;AAAA,QACpBV,YAAY;AAAA,QACZC,YAAY;AAAA,UACVU,MAAM;AAAA;AAAA,UACNC,OAAOC,KAAKC,UAAUP,GAAG;AAAA,UACzBlB,SAASmB;AAAAA,QAAAA;AAAAA,MACX,CACD;AAAA,IAAA;AAAA,EACH,GACC,CAACrB,QAAQC,OAAOC,SAASC,aAAaQ,uBAAuBJ,QAAQ,CAAC;AAEnEqB,QAAAA,eAAeC,QACnB,OAAO;AAAA,IACLnB;AAAAA,IACAQ;AAAAA,EAAAA,IAEF,CAACR,iBAAiBQ,UAAU,CAC9B;AAEA,6BACG,iBAAiB,UAAjB,EAA0B,OAAOU,cAC/BhC,UACH;AAEJ;"}