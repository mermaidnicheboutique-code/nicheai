import { jsx } from "react/jsx-runtime";
import { createContext, useCallback, useMemo, useContext } from "react";
import { useIsMounted } from "usehooks-ts";
import { useLifecycleStatus } from "../../internal/hooks/useLifecycleStatus.js";
import { GENERIC_ERROR_MESSAGE } from "../../transaction/constants.js";
import { isUserRejectedRequestError } from "../../transaction/utils/isUserRejectedRequestError.js";
import { useSignData } from "../hooks/useSignData.js";
const SignatureContext = createContext(null);
function useSignatureContext() {
  const context = useContext(SignatureContext);
  if (!context) {
    throw new Error("useSignatureContext must be used within a SignatureProvider");
  }
  return context;
}
function SignatureProvider({
  children,
  onSuccess,
  onError,
  onStatus,
  domain,
  types,
  message,
  primaryType,
  resetAfter
}) {
  const isMounted = useIsMounted();
  const {
    signData,
    resetSignData
  } = useSignData();
  const [lifecycleStatus, updateLifecycleStatus] = useLifecycleStatus({
    statusName: "init",
    statusData: null
  }, {
    onStatus: (status) => {
      onStatus == null ? void 0 : onStatus(status);
      if (status.statusName === "error") {
        onError == null ? void 0 : onError(status.statusData);
      }
      if (status.statusName !== "success") {
        return;
      }
      onSuccess == null ? void 0 : onSuccess(status.statusData.signature);
      if (resetAfter) {
        setTimeout(() => {
          if (!isMounted()) return;
          resetSignData();
          updateLifecycleStatus({
            statusName: "init",
            statusData: null
          });
        }, resetAfter);
      }
    }
  });
  const handleSign = useCallback(async () => {
    updateLifecycleStatus({
      statusName: "pending"
    });
    try {
      const signature = await signData({
        domain,
        types,
        message,
        primaryType
      });
      updateLifecycleStatus({
        statusName: "success",
        statusData: {
          signature
        }
      });
    } catch (err) {
      const errorMessage = isUserRejectedRequestError(err) ? "Request denied." : GENERIC_ERROR_MESSAGE;
      updateLifecycleStatus({
        statusName: "error",
        statusData: {
          code: "SmSPc01",
          // Signature module SignatureProvider component 01 error
          error: JSON.stringify(err),
          message: errorMessage
        }
      });
    }
  }, [domain, types, message, primaryType, updateLifecycleStatus, signData]);
  const contextValue = useMemo(() => ({
    lifecycleStatus,
    handleSign
  }), [lifecycleStatus, handleSign]);
  return /* @__PURE__ */ jsx(SignatureContext.Provider, { value: contextValue, children });
}
export {
  SignatureProvider,
  useSignatureContext
};
//# sourceMappingURL=SignatureProvider.js.map
