{"version":3,"file":"useThrottle.js","sources":["../../../src/internal/hooks/useThrottle.ts"],"sourcesContent":["import { useCallback, useEffect, useRef } from 'react';\n\ntype AnyFunction = (...args: unknown[]) => unknown;\n\n/**\n * A hook that returns a throttled version of a callback function.\n * Throttling ensures the callback is executed at most once within the specified delay period.\n *\n * @param callback - The function to throttle\n * @param delay - The number of milliseconds to wait before allowing another execution\n *\n * @returns A throttled version of the callback that maintains the same arguments\n * and automatically cleans up any pending executions on unmount\n *\n * More details on throttle: https://developer.mozilla.org/en-US/docs/Glossary/Throttle\n */\nexport const useThrottle = <T extends AnyFunction>(\n  callback: T,\n  delay: number,\n): ((...args: Parameters<T>) => void) => {\n  const lastCallTime = useRef<number>(0);\n  const timeoutRef = useRef<NodeJS.Timeout | undefined>(undefined);\n  const lastArgsRef = useRef<Parameters<T> | undefined>(undefined);\n  const callbackRef = useRef(callback);\n  callbackRef.current = callback;\n\n  // Cleanup on unmount\n  useEffect(() => {\n    return () => {\n      if (timeoutRef.current) {\n        clearTimeout(timeoutRef.current);\n      }\n    };\n  }, []);\n\n  return useCallback(\n    (...args: Parameters<T>) => {\n      const now = Date.now();\n      const timeSinceLastCall = now - lastCallTime.current;\n\n      if (timeSinceLastCall >= delay) {\n        // Execute immediately if enough time has passed\n        callbackRef.current(...args);\n        lastCallTime.current = now;\n      } else if (timeoutRef.current) {\n        // Update the scheduled execution with the latest arguments\n        lastArgsRef.current = args;\n      } else if (!timeoutRef.current) {\n        // Store args for delayed execution\n        lastArgsRef.current = args;\n        // Schedule next execution at the end of delay period\n        timeoutRef.current = setTimeout(() => {\n          if (lastArgsRef.current) {\n            callbackRef.current(...lastArgsRef.current);\n            lastCallTime.current = Date.now();\n          }\n          timeoutRef.current = undefined;\n        }, delay - timeSinceLastCall);\n      }\n    },\n    [delay],\n  );\n};\n"],"names":["useThrottle","callback","delay","lastCallTime","useRef","timeoutRef","undefined","lastArgsRef","callbackRef","current","useEffect","clearTimeout","useCallback","args","now","Date","timeSinceLastCall","setTimeout"],"mappings":";AAgBaA,MAAAA,cAAc,CACzBC,UACAC,UACuC;AACjCC,QAAAA,eAAeC,OAAe,CAAC;AAC/BC,QAAAA,aAAaD,OAAmCE,MAAS;AACzDC,QAAAA,cAAcH,OAAkCE,MAAS;AACzDE,QAAAA,cAAcJ,OAAOH,QAAQ;AACnCO,cAAYC,UAAUR;AAGtBS,YAAU,MAAM;AACd,WAAO,MAAM;AACX,UAAIL,WAAWI,SAAS;AACtBE,qBAAaN,WAAWI,OAAO;AAAA,MAAA;AAAA,IAEnC;AAAA,EACF,GAAG,EAAE;AAEEG,SAAAA,YACL,IAAIC,SAAwB;AACpBC,UAAAA,MAAMC,KAAKD,IAAI;AACfE,UAAAA,oBAAoBF,MAAMX,aAAaM;AAE7C,QAAIO,qBAAqBd,OAAO;AAElBO,kBAAAA,QAAQ,GAAGI,IAAI;AAC3BV,mBAAaM,UAAUK;AAAAA,IAAAA,WACdT,WAAWI,SAAS;AAE7BF,kBAAYE,UAAUI;AAAAA,IAAAA,WACb,CAACR,WAAWI,SAAS;AAE9BF,kBAAYE,UAAUI;AAEXJ,iBAAAA,UAAUQ,WAAW,MAAM;AACpC,YAAIV,YAAYE,SAAS;AACXA,sBAAAA,QAAQ,GAAGF,YAAYE,OAAO;AAC7BA,uBAAAA,UAAUM,KAAKD,IAAI;AAAA,QAAA;AAElCT,mBAAWI,UAAUH;AAAAA,MAAAA,GACpBJ,QAAQc,iBAAiB;AAAA,IAAA;AAAA,EAC9B,GAEF,CAACd,KAAK,CACR;AACF;"}